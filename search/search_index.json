{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Environneements immersifs - C\u00e9gep de Victoriaville","text":""},{"location":"#enseignant","title":"Enseignant","text":"<p>Fr\u00e9d\u00e9rik Taleb</p>"},{"location":"#horaire","title":"Horaire","text":"<p>Vendredi de 14h15 \u00e0 17h05</p> <p>Classe : C-209</p> <p></p>"},{"location":"config_simulation_ar/","title":"Configuration AR Foundation et Simulation AR","text":""},{"location":"config_simulation_ar/#pourquoi-utiliser-la-simulation-ar","title":"Pourquoi utiliser la simulation AR?","text":"<p>D\u00e9velopper en AR n\u00e9cessite normalement de d\u00e9ployer votre app sur un appareil mobile \u00e0 chaque test. C'est :</p> <ul> <li>\u23f1\ufe0f Long : Build + transfert + installation = 5-10 minutes par test</li> <li>\ud83d\udcb0 Co\u00fbteux : N\u00e9cessite un appareil physique compatible</li> <li>\ud83d\udc1b Difficile \u00e0 d\u00e9boguer : Pas d'acc\u00e8s direct \u00e0 la console Unity</li> </ul> <p>La simulation AR r\u00e9sout tous ces probl\u00e8mes !</p>"},{"location":"config_simulation_ar/#avantages-de-la-simulation","title":"Avantages de la simulation","text":"<ul> <li>\u2705 Test instantan\u00e9 : Play dans l'\u00e9diteur Unity</li> <li>\u2705 D\u00e9bogage facile : Console, Debug.Log, breakpoints</li> <li>\u2705 Pas d'appareil n\u00e9cessaire : D\u00e9veloppez n'importe o\u00f9</li> <li>\u2705 It\u00e9ration rapide : Testez et modifiez en quelques secondes</li> <li>\u2705 Environnements contr\u00f4l\u00e9s : Sc\u00e8nes de test pr\u00e9-configur\u00e9es</li> </ul> <p>Note importante : La simulation n'est pas parfaite \u00e0 100%, mais elle permet de d\u00e9velopper 90% de votre app avant de tester sur appareil physique.</p>"},{"location":"config_simulation_ar/#partie-1-installation-des-packages-necessaires","title":"Partie 1 : Installation des packages n\u00e9cessaires","text":""},{"location":"config_simulation_ar/#etape-11-ouvrir-le-package-manager","title":"\u00c9tape 1.1 : Ouvrir le Package Manager","text":"<ol> <li>Dans Unity, allez \u00e0 Window \u2192 Package Manager</li> <li>En haut \u00e0 gauche, changez le menu d\u00e9roulant de \"In Project\" \u00e0 \"Unity Registry\"</li> </ol>"},{"location":"config_simulation_ar/#etape-12-installer-ar-foundation","title":"\u00c9tape 1.2 : Installer AR Foundation","text":"<ol> <li>Dans la barre de recherche, tapez \"AR Foundation\"</li> <li>S\u00e9lectionnez AR Foundation</li> <li>Cliquez sur Install (en bas \u00e0 droite)</li> <li>Attendez la fin de l'installation</li> </ol> <p>Version recommand\u00e9e : 5.0 ou plus r\u00e9cent</p>"},{"location":"config_simulation_ar/#etape-13-installer-arcore-xr-plugin","title":"\u00c9tape 1.3 : Installer ARCore XR Plugin","text":"<ol> <li>Toujours dans le Package Manager</li> <li>Cherchez Google ARCore XR Plugin</li> <li>Cliquez sur Install</li> <li>Attendez la fin de l'installation</li> </ol> <p>Note : Si vous voulez aussi supporter iOS, installez \u00e9galement Apple ARKit XR Plugin.</p>"},{"location":"config_simulation_ar/#partie-2-configuration-du-projet-unity","title":"Partie 2 : Configuration du projet Unity","text":""},{"location":"config_simulation_ar/#etape-21-parametres-xr-plug-in-management","title":"\u00c9tape 2.1 : Param\u00e8tres XR Plug-in Management","text":"<ol> <li>Allez \u00e0 Edit \u2192 Project Settings</li> <li>Dans le panneau de gauche, s\u00e9lectionnez XR Plug-in Management</li> <li>Si demand\u00e9, cliquez sur Install XR Plugin Management</li> </ol> <p>Onglet PC, Mac &amp; Linux Standalone :</p> <ol> <li>Cochez XR Simulation (ou AR Simulation)</li> </ol> <p>Onglet Android :</p> <ol> <li>Cochez Google ARCore</li> </ol>"},{"location":"config_simulation_ar/#etape-22-parametres-de-build-android","title":"\u00c9tape 2.2 : Param\u00e8tres de build Android","text":"<p>Toujours dans Project Settings :</p> <ol> <li>S\u00e9lectionnez Player dans le panneau de gauche</li> <li>Cliquez sur l'onglet Android (ic\u00f4ne Android)</li> <li> <p>Section Other Settings :</p> </li> <li> <p>Minimum API Level : Android 7.0 (API level 24) ou plus</p> </li> <li>Scripting Backend : IL2CPP (recommand\u00e9 pour les performances)</li> <li> <p>Target Architectures : Cochez ARM64</p> </li> <li> <p>Dans Publishing Settings :</p> </li> <li> <p>D\u00e9cochez Custom Main Manifest (sauf si vous savez ce que vous faites)</p> </li> </ol>"},{"location":"config_simulation_ar/#etape-23-verification-de-la-configuration","title":"\u00c9tape 2.3 : V\u00e9rification de la configuration","text":"<p>Dans XR Plug-in Management :</p> <ul> <li>\u2705 Desktop : XR Simulation activ\u00e9</li> <li>\u2705 Android : Google ARCore activ\u00e9</li> </ul>"},{"location":"config_simulation_ar/#partie-3-creation-dune-scene-ar-de-base","title":"Partie 3 : Cr\u00e9ation d'une sc\u00e8ne AR de base","text":""},{"location":"config_simulation_ar/#etape-31-creer-une-nouvelle-scene","title":"\u00c9tape 3.1 : Cr\u00e9er une nouvelle sc\u00e8ne","text":"<ol> <li>File \u2192 New Scene</li> <li>Choisissez 3D (pas URP ou HDRP pour simplifier)</li> <li>File \u2192 Save As \u2192 Nommez-la \"TestAR\"</li> </ol>"},{"location":"config_simulation_ar/#etape-32-supprimer-la-camera-par-defaut","title":"\u00c9tape 3.2 : Supprimer la cam\u00e9ra par d\u00e9faut","text":"<ol> <li>Dans la Hierarchy, clic droit sur \"Main Camera\"</li> <li>S\u00e9lectionnez Delete</li> </ol> <p>Pourquoi? ARCore utilise sa propre cam\u00e9ra sp\u00e9ciale qui affiche le flux vid\u00e9o r\u00e9el.</p>"},{"location":"config_simulation_ar/#etape-33-ajouter-xr-origin","title":"\u00c9tape 3.3 : Ajouter XR Origin","text":"<ol> <li>Clic droit dans la Hierarchy</li> <li>XR \u2192 XR Origin (Mobile AR)</li> </ol> <p>Ceci cr\u00e9e automatiquement :</p> <ul> <li>XR Origin : GameObject parent qui g\u00e8re le syst\u00e8me de coordonn\u00e9es</li> <li>Camera Offset : GameObject interm\u00e9diaire</li> <li>Main Camera : Cam\u00e9ra AR qui affiche le monde r\u00e9el + objets virtuels</li> </ul>"},{"location":"config_simulation_ar/#etape-34-ajouter-ar-session","title":"\u00c9tape 3.4 : Ajouter AR Session","text":"<ol> <li>Clic droit dans la Hierarchy</li> <li>XR \u2192 AR Session</li> </ol> <p>Ce GameObject g\u00e8re l'\u00e9tat de la session AR (d\u00e9marrage, pause, arr\u00eat).</p>"},{"location":"config_simulation_ar/#etape-35-ajouter-les-managers-necessaires","title":"\u00c9tape 3.5 : Ajouter les managers n\u00e9cessaires","text":"<p>S\u00e9lectionnez le GameObject XR Origin et ajoutez les composants suivants :</p> <ol> <li>Add Component \u2192 AR Plane Manager</li> <li> <p>G\u00e8re la d\u00e9tection de plans</p> </li> <li> <p>Add Component \u2192 AR Raycast Manager</p> </li> <li> <p>Permet les raycasts AR</p> </li> <li> <p>Add Component \u2192 AR Anchor Manager (optionnel pour l'instant)</p> </li> <li>G\u00e8re les ancres</li> </ol> <p>Configuration AR Plane Manager :</p> <ul> <li>Plane Prefab : Laissez vide pour l'instant (Unity utilisera un prefab par d\u00e9faut)</li> <li>Detection Mode : Everything (d\u00e9tecte tous les types de plans)</li> </ul>"},{"location":"config_simulation_ar/#partie-4-configuration-de-la-simulation","title":"Partie 4 : Configuration de la simulation","text":""},{"location":"config_simulation_ar/#etape-41-acceder-aux-parametres-de-simulation","title":"\u00c9tape 4.1 : Acc\u00e9der aux param\u00e8tres de simulation","text":"<ol> <li>Edit \u2192 Project Settings</li> <li>Dans le panneau de gauche, cherchez XR Plug-in Management</li> <li>Cliquez sur XR Simulation (sous-menu)</li> </ol>"},{"location":"config_simulation_ar/#etape-42-choisir-un-environnement-de-simulation","title":"\u00c9tape 4.2 : Choisir un environnement de simulation","text":"<p>Dans Window &gt; XR &gt; AR Foundation &gt; XR Environment, vous verrez une liste d'environnements :</p> <p>Il faudra importer les environnements de simulation</p> <p>S\u00e9lectionnez un petit environnement pour commencer.</p>"},{"location":"config_simulation_ar/#configurer-urp","title":"Configurer URP","text":"<p>Si votre projet utilise le Universal Renderer Pipeline, la simulation offre seulement un carr\u00e9 jaune pour le moment!</p> <ol> <li>Acc\u00e9dez \u00e0 Assets &gt; Settings</li> <li>Choisissez le Universal Renderer (PC_Renderer dans votre projet)</li> <li>Ajoutez la composante AR Background Renderer Feature</li> </ol>"},{"location":"config_simulation_ar/#etape-43-configuration-des-controles","title":"\u00c9tape 4.3 : Configuration des contr\u00f4les","text":"<p>Contr\u00f4les par d\u00e9faut :</p> <ul> <li>Clic droit + mouvement souris : Regarder autour</li> <li>WASD : Se d\u00e9placer</li> <li>Q/E : Monter/descendre</li> <li>Shift : Augmenter la vitesse</li> </ul>"},{"location":"config_simulation_ar/#partie-5-test-de-base","title":"Partie 5 : Test de base","text":""},{"location":"config_simulation_ar/#etape-51-lancer-la-simulation","title":"\u00c9tape 5.1 : Lancer la simulation","text":"<ol> <li>Appuyez sur Play dans Unity</li> <li>La sc\u00e8ne de simulation devrait se charger</li> <li>Vous devriez voir l'environnement 3D s\u00e9lectionn\u00e9</li> </ol>"},{"location":"config_simulation_ar/#etape-52-verifier-la-detection-de-plans","title":"\u00c9tape 5.2 : V\u00e9rifier la d\u00e9tection de plans","text":"<p>Visuel attendu :</p> <ul> <li>Des grilles blanches/grises apparaissent sur le sol et les surfaces</li> <li>Ces grilles repr\u00e9sentent les plans d\u00e9tect\u00e9s</li> </ul> <p>Si rien n'appara\u00eet :</p> <ul> <li>V\u00e9rifiez que AR Plane Manager est bien sur XR Origin</li> <li>V\u00e9rifiez que la simulation est activ\u00e9e dans Project Settings</li> </ul>"},{"location":"config_simulation_ar/#etape-53-naviguer-dans-la-simulation","title":"\u00c9tape 5.3 : Naviguer dans la simulation","text":"<p>Utilisez les contr\u00f4les :</p> <ul> <li>Clic droit + souris pour regarder autour</li> <li>WASD pour vous d\u00e9placer</li> <li>Observez comment les plans sont d\u00e9tect\u00e9s</li> </ul>"},{"location":"config_simulation_ar/#partie-6-ajouter-un-prefab-pour-visualiser-les-plans","title":"Partie 6 : Ajouter un prefab pour visualiser les plans","text":""},{"location":"config_simulation_ar/#etape-61-creer-le-prefab-de-plan","title":"\u00c9tape 6.1 : Cr\u00e9er le prefab de plan","text":"<ol> <li>Ajoutez \u00e0 la sc\u00e8ne XR \u2192 AR Default Plane</li> <li>Renommez-le ARPlanePrefab</li> </ol>"},{"location":"config_simulation_ar/#etape-62-creer-un-prefab-et-lassigner","title":"\u00c9tape 6.2 : Cr\u00e9er un prefab et l'assigner","text":"<ol> <li>Glissez ARPlanePrefab de la Hierarchy vers le dossier Assets</li> <li>Supprimez ARPlanePrefab de la Hierarchy</li> <li>S\u00e9lectionnez XR Origin dans la Hierarchy</li> <li> <p>Dans le composant AR Plane Manager :</p> </li> <li> <p>Glissez le prefab dans le champ Plane Prefab</p> </li> </ol>"},{"location":"config_simulation_ar/#etape-63-tester","title":"\u00c9tape 6.3 : Tester","text":"<ol> <li>Appuyez sur Play</li> <li>Les plans d\u00e9tect\u00e9s devraient maintenant appara\u00eetre en bleu semi-transparent</li> <li>D\u00e9placez-vous pour voir les plans s'agrandir et fusionner</li> </ol>"},{"location":"config_simulation_ar/#partie-7-workflow-de-developpement-recommande","title":"Partie 7 : Workflow de d\u00e9veloppement recommand\u00e9","text":""},{"location":"config_simulation_ar/#phase-1-developpement-initial-90-du-temps","title":"Phase 1 : D\u00e9veloppement initial (90% du temps)","text":"<pre><code>Coder dans Unity\n    \u2193\nTester dans la simulation (Play dans l'\u00e9diteur)\n    \u2193\nIt\u00e9rer rapidement\n</code></pre> <p>Avantages :</p> <ul> <li>Cycles de test en secondes</li> <li>Debug facile</li> <li>Pas besoin d'appareil</li> </ul>"},{"location":"config_simulation_ar/#phase-2-validation-10-du-temps","title":"Phase 2 : Validation (10% du temps)","text":"<pre><code>Build Android\n    \u2193\nInstaller sur appareil\n    \u2193\nTester en conditions r\u00e9elles\n</code></pre> <p>Quand faire un build : - \u2705 Fin d'une feature compl\u00e8te - \u2705 Avant une d\u00e9mo - \u2705 V\u00e9rification finale</p>"},{"location":"config_simulation_ar/#phase-3-debug-sur-appareil-si-necessaire","title":"Phase 3 : Debug sur appareil (si n\u00e9cessaire)","text":"<p>Si quelque chose ne fonctionne pas sur l'appareil :</p> <ol> <li>Build \u2192 Development Build + Script Debugging</li> <li>Connectez l'appareil en USB</li> <li>Window \u2192 Analysis \u2192 Android Logcat</li> <li>Consultez les logs en temps r\u00e9el</li> </ol>"},{"location":"config_simulation_ar/#partie-8-limitations-de-la-simulation","title":"Partie 8 : Limitations de la simulation","text":""},{"location":"config_simulation_ar/#ce-qui-fonctionne-bien","title":"Ce qui fonctionne bien \u2705","text":"<ul> <li>D\u00e9tection de plans</li> <li>Raycasting AR</li> <li>Placement d'objets</li> <li>Gestion des ancres</li> <li>Input tactile (avec Device Simulator)</li> <li>Logique de gameplay</li> </ul>"},{"location":"config_simulation_ar/#ce-qui-ne-fonctionne-pas","title":"Ce qui ne fonctionne pas \u26a0\ufe0f","text":"<ul> <li>Estimation d'\u00e9clairage r\u00e9el : La simulation utilise un \u00e9clairage fixe</li> <li>Cam\u00e9ra r\u00e9elle : Pas de flux vid\u00e9o r\u00e9el (fond virtuel)</li> <li>Performance r\u00e9elle : Un PC est plus puissant qu'un t\u00e9l\u00e9phone</li> <li>Sensors sp\u00e9cifiques : GPS, gyroscope r\u00e9el, etc.</li> </ul>"},{"location":"config_simulation_ar/#strategie-recommandee","title":"Strat\u00e9gie recommand\u00e9e","text":"<p>D\u00e9veloppez en simulation, puis testez sur appareil pour :</p> <ul> <li>Valider l'int\u00e9gration de la cam\u00e9ra r\u00e9elle</li> <li>V\u00e9rifier les performances</li> <li>Tester l'estimation d'\u00e9clairage</li> <li>Valider l'exp\u00e9rience utilisateur compl\u00e8te</li> </ul>"},{"location":"config_simulation_ar/#depannage","title":"D\u00e9pannage","text":""},{"location":"config_simulation_ar/#les-plans-ne-sont-pas-detectes","title":"\u274c Les plans ne sont pas d\u00e9tect\u00e9s","text":"<p>V\u00e9rifications :</p> <ol> <li>AR Plane Manager est sur XR Origin ?</li> <li>XR Simulation est activ\u00e9 dans Project Settings \u2192 XR Plug-in Management (onglet Desktop) ?</li> <li>Un environnement de simulation est s\u00e9lectionn\u00e9 ?</li> </ol>"},{"location":"config_simulation_ar/#arsession-is-not-enabled","title":"\u274c \"ARSession is not enabled\"","text":"<p>Solution :</p> <ol> <li>V\u00e9rifiez qu'il y a un GameObject \"AR Session\" dans la sc\u00e8ne</li> <li>V\u00e9rifiez que le composant AR Session n'est pas d\u00e9sactiv\u00e9</li> </ol>"},{"location":"config_simulation_ar/#la-camera-ne-bouge-pas","title":"\u274c La cam\u00e9ra ne bouge pas","text":"<p>V\u00e9rifications :</p> <ol> <li>Vous \u00eates bien en mode Play</li> <li>La fen\u00eatre Game est bien s\u00e9lectionn\u00e9e (pas Scene)</li> <li>Cliquez sur la fen\u00eatre Game avant d'utiliser les contr\u00f4les</li> </ol>"},{"location":"config_simulation_ar/#checklist-de-configuration-complete","title":"Checklist de configuration compl\u00e8te","text":"<p>Avant de commencer \u00e0 d\u00e9velopper, v\u00e9rifiez :</p> <p>Packages :</p> <ul> <li>[ ] AR Foundation install\u00e9</li> <li>[ ] Google ARCore XR Plugin install\u00e9</li> </ul> <p>Project Settings :</p> <ul> <li>[ ] XR Simulation activ\u00e9 (onglet Desktop)</li> <li>[ ] ARCore activ\u00e9 (onglet Android)</li> <li>[ ] Environnement de simulation s\u00e9lectionn\u00e9</li> </ul> <p>Sc\u00e8ne :</p> <ul> <li>[ ] Pas de Main Camera par d\u00e9faut</li> <li>[ ] XR Origin pr\u00e9sent</li> <li>[ ] AR Session pr\u00e9sent</li> <li>[ ] AR Plane Manager sur XR Origin</li> <li>[ ] AR Raycast Manager sur XR Origin</li> </ul> <p>Test :</p> <ul> <li>[ ] Play fonctionne</li> <li>[ ] Plans d\u00e9tect\u00e9s (grilles visibles)</li> <li>[ ] Navigation fonctionnelle (WASD + souris)</li> </ul>"},{"location":"config_simulation_ar/#ressources-complementaires","title":"Ressources compl\u00e9mentaires","text":"<ul> <li>Documentation AR Foundation</li> <li>XR Simulation Documentation</li> <li>ARCore Documentation</li> </ul>"},{"location":"config_simulation_ar/#questions-de-comprehension","title":"Questions de compr\u00e9hension","text":"<ol> <li>Quels sont les trois packages n\u00e9cessaires pour d\u00e9velopper en AR avec simulation ?</li> <li>Pourquoi doit-on supprimer la cam\u00e9ra par d\u00e9faut lors de la cr\u00e9ation d'une sc\u00e8ne AR ?</li> <li>Quelle est la diff\u00e9rence entre XR Origin et AR Session ?</li> <li>Quels sont les avantages de d\u00e9velopper en simulation plut\u00f4t que directement sur appareil ?</li> <li>Quelles sont les principales limitations de la simulation AR ?</li> </ol>"},{"location":"exercice_adaptation_ar/","title":"Exercice pratique - Passage du raycasting 3D \u00e0 la r\u00e9alit\u00e9 augment\u00e9e","text":""},{"location":"exercice_adaptation_ar/#objectifs-de-lexercice","title":"Objectifs de l'exercice","text":"<p>Dans cet exercice, vous allez adapter votre projet de peinture 3D de la semaine 1 pour qu'il fonctionne en r\u00e9alit\u00e9 augment\u00e9e. Concr\u00e8tement, vous allez :</p> <ol> <li>\u2705 Configurer votre projet existant pour l'AR</li> <li>\u2705 Remplacer le sol fixe par des plans d\u00e9tect\u00e9s dynamiquement</li> <li>\u2705 Adapter le raycasting pour toucher les plans AR</li> <li>\u2705 Tester en simulation AR</li> <li>\u2705 BONUS : Ajouter un syst\u00e8me de feedback visuel pendant la d\u00e9tection</li> </ol> <p>Dur\u00e9e approximative : 60-90 minutes</p> <p>Pr\u00e9requis : Avoir compl\u00e9t\u00e9 l'exercice de raycasting 3D de la semaine 1</p>"},{"location":"exercice_adaptation_ar/#etape-1-preparation-du-projet","title":"\u00c9tape 1 : Pr\u00e9paration du projet","text":""},{"location":"exercice_adaptation_ar/#11-ouvrir-votre-projet-de-la-semaine-1","title":"1.1 : Ouvrir votre projet de la semaine 1","text":"<ol> <li>Ouvrez Unity Hub</li> <li>Ouvrez votre projet <code>RaycastingExercice</code> de la semaine 1</li> <li> <p>Cr\u00e9ez une copie de votre sc\u00e8ne actuelle :</p> </li> <li> <p>Clic droit sur votre sc\u00e8ne \u2192 Duplicate</p> </li> <li>Renommez la copie \"SceneAR\"</li> <li>Ouvrez cette nouvelle sc\u00e8ne</li> </ol> <p>Pourquoi une copie ? Pour garder votre version 3D classique intacte au cas o\u00f9.</p>"},{"location":"exercice_adaptation_ar/#12-installer-les-packages-ar","title":"1.2 : Installer les packages AR","text":"<p>Suivez la Partie 1 du document \"Configuration AR Foundation et Simulation AR\" :</p> <ul> <li>[ ] Installer AR Foundation</li> <li>[ ] Installer Google ARCore XR Plugin</li> <li>[ ] Installer XR Simulation</li> </ul>"},{"location":"exercice_adaptation_ar/#13-configurer-les-parametres-du-projet","title":"1.3 : Configurer les param\u00e8tres du projet","text":"<p>Suivez la Partie 2 du m\u00eame document :</p> <ul> <li>[ ] Activer XR Simulation (Desktop)</li> <li>[ ] Activer Google ARCore (Android)</li> <li>[ ] Configurer les param\u00e8tres Android</li> </ul>"},{"location":"exercice_adaptation_ar/#etape-2-transformer-la-scene-en-scene-ar","title":"\u00c9tape 2 : Transformer la sc\u00e8ne en sc\u00e8ne AR","text":""},{"location":"exercice_adaptation_ar/#21-supprimer-les-elements-non-compatibles","title":"2.1 : Supprimer les \u00e9l\u00e9ments non compatibles","text":"<p>Dans votre sc\u00e8ne actuelle, supprimez :</p> <ol> <li>\u274c Le Plane (sol) - il sera remplac\u00e9 par la d\u00e9tection de plans AR</li> <li>\u274c La Main Camera par d\u00e9faut</li> </ol> <p>Gardez :</p> <ul> <li>\u2705 Votre GameObject \"Utilisateur\" (ou \"GameManager\") avec le script de placement</li> <li>\u2705 Le prefab de cube</li> <li>\u2705 La sph\u00e8re en mouvement (si vous l'avez cr\u00e9\u00e9e)</li> </ul>"},{"location":"exercice_adaptation_ar/#22-ajouter-les-composants-ar","title":"2.2 : Ajouter les composants AR","text":"<p>Suivez la Partie 3 du document de configuration :</p> <ol> <li> <p>Ajouter XR Origin :</p> </li> <li> <p>Clic droit dans Hierarchy \u2192 XR \u2192 XR Origin (Mobile AR)</p> </li> <li> <p>Ajouter AR Session :</p> </li> <li> <p>Clic droit dans Hierarchy \u2192 XR \u2192 AR Session</p> </li> <li> <p>Configurer XR Origin :</p> </li> <li> <p>S\u00e9lectionnez XR Origin</p> </li> <li>Add Component \u2192 AR Plane Manager</li> <li>Add Component \u2192 AR Raycast Manager</li> </ol>"},{"location":"exercice_adaptation_ar/#23-creer-et-assigner-le-prefab-de-plan","title":"2.3 : Cr\u00e9er et assigner le prefab de plan","text":"<p>Suivez la Partie 6 du document de configuration pour cr\u00e9er un prefab de plan visualisable.</p> <p>Configuration recommand\u00e9e pour cet exercice :</p> <ul> <li>Mat\u00e9riau : Vert semi-transparent (Alpha ~0.4)</li> <li>Cela permet de voir clairement o\u00f9 sont les surfaces d\u00e9tect\u00e9es</li> </ul> <p>Assignez le prefab dans AR Plane Manager \u2192 Plane Prefab</p>"},{"location":"exercice_adaptation_ar/#24-configurer-la-simulation","title":"2.4 : Configurer la simulation","text":"<ol> <li>Edit \u2192 Project Settings \u2192 XR Simulation</li> <li>S\u00e9lectionnez \"Simulated Room\" comme environnement</li> <li>Testez en appuyant sur Play - vous devriez voir l'environnement de simulation</li> </ol>"},{"location":"exercice_adaptation_ar/#etape-3-adapter-le-script-de-placement","title":"\u00c9tape 3 : Adapter le script de placement","text":"<p>C'est l'\u00e9tape cl\u00e9 ! Vous allez modifier votre script <code>PlacementRaycast.cs</code> pour utiliser le raycasting AR.</p>"},{"location":"exercice_adaptation_ar/#31-ajouter-les-namespaces-necessaires","title":"3.1 : Ajouter les namespaces n\u00e9cessaires","text":"<p>En haut de votre script, ajoutez :</p> <pre><code>using UnityEngine.XR.ARFoundation;\nusing UnityEngine.XR.ARSubsystems;\n</code></pre>"},{"location":"exercice_adaptation_ar/#32-ajouter-une-reference-a-ar-raycast-manager","title":"3.2 : Ajouter une r\u00e9f\u00e9rence \u00e0 AR Raycast Manager","text":"<p>Dans votre classe, ajoutez :</p> <pre><code>[SerializeField] private ARRaycastManager arRaycastManager;\n</code></pre> <p>Dans Unity :</p> <ol> <li>S\u00e9lectionnez votre GameObject \"Utilisateur\"</li> <li>Dans l'Inspector, trouvez votre script</li> <li>Glissez XR Origin dans le champ AR Raycast Manager    (XR Origin a le composant AR Raycast Manager)</li> </ol>"},{"location":"exercice_adaptation_ar/#33-comprendre-la-difference-entre-les-deux-types-de-raycast","title":"3.3 : Comprendre la diff\u00e9rence entre les deux types de raycast","text":"<p>Raycasting 3D classique :</p> <pre><code>// Touche des COLLIDERS Unity\nRay ray = Camera.main.ScreenPointToRay(touchPosition);\nif (Physics.Raycast(ray, out RaycastHit hit))\n{\n    // hit contient des infos sur le collider touch\u00e9\n}\n</code></pre> <p>Raycasting AR (Nouvelle m\u00e9thode) :</p> <pre><code>// Touche des PLANS D\u00c9TECT\u00c9S par ARCore\nList&lt;ARRaycastHit&gt; hits = new List&lt;ARRaycastHit&gt;();\nif (arRaycastManager.Raycast(touchPosition, hits, TrackableType.PlaneWithinPolygon))\n{\n    // hits[0] contient des infos sur le plan AR touch\u00e9\n}\n</code></pre>"},{"location":"exercice_adaptation_ar/#34-modifier-la-methode-de-placement","title":"3.4 : Modifier la m\u00e9thode de placement","text":"<p>Remplacez votre m\u00e9thode de placement existante par cette version AR :</p> <pre><code>private void OnTap(InputAction.CallbackContext context)\n{\n    // Obtenir la position du touch/clic\n    Vector2 touchPosition = controles.Player.Point.ReadValue&lt;Vector2&gt;();\n\n    // Liste pour stocker les r\u00e9sultats du raycast AR\n    List&lt;ARRaycastHit&gt; hits = new List&lt;ARRaycastHit&gt;();\n\n    // Lancer un raycast AR vers les plans d\u00e9tect\u00e9s\n    if (arRaycastManager.Raycast(touchPosition, hits, TrackableType.PlaneWithinPolygon))\n    {\n        // Prendre le premier plan touch\u00e9\n        Pose hitPose = hits[0].pose;\n\n        // Cr\u00e9er le cube \u00e0 la position du plan\n        GameObject nouveauCube = Instantiate(cubePrefab, hitPose.position, Quaternion.identity);\n\n        // Appliquer la couleur actuelle\n        Renderer renderer = nouveauCube.GetComponent&lt;Renderer&gt;();\n        if (renderer != null)\n        {\n            renderer.material.color = couleurActuelle;\n        }\n\n        // Assigner le tag pour pouvoir supprimer plus tard\n        nouveauCube.tag = \"Cube\";\n    }\n}\n</code></pre>"},{"location":"exercice_adaptation_ar/#35-points-importants-a-noter","title":"3.5 : Points importants \u00e0 noter","text":"<p><code>TrackableType.PlaneWithinPolygon</code> :</p> <ul> <li>Ne touche que les plans d\u00e9tect\u00e9s (pas les objets virtuels)</li> <li>\u00c9quivalent AR du LayerMask pour ignorer certains objets</li> </ul> <p><code>hits[0].pose</code> :</p> <ul> <li>Un <code>Pose</code> contient position ET rotation</li> <li><code>pose.position</code> = Vector3 de la position</li> <li><code>pose.rotation</code> = Quaternion de la rotation</li> </ul> <p>Pourquoi <code>Quaternion.identity</code> ?</p> <ul> <li>Pour cet exercice, on garde les cubes non-rot\u00e9s pour simplifier</li> <li>On pourrait utiliser <code>hitPose.rotation</code> pour aligner avec la surface</li> </ul>"},{"location":"exercice_adaptation_ar/#36-adapter-la-suppression","title":"3.6 : Adapter la suppression","text":"<p>Modifiez le syst\u00e8me de suppression au clic droit de la m\u00eame mani\u00e8re :</p> <pre><code>private void OnDelete(InputAction.CallbackContext context)\n{\n    Vector2 touchPosition = controles.Player.Point.ReadValue&lt;Vector2&gt;();\n\n    // On peut utiliser le raycast CLASSIQUE pour toucher les cubes\n    Ray ray = Camera.main.ScreenPointToRay(touchPosition);\n    if (Physics.Raycast(ray, out RaycastHit hit))\n    {\n        if (hit.collider.CompareTag(\"Cube\"))\n        {\n            Destroy(hit.collider.gameObject);\n        }\n    }\n}\n</code></pre> <p>Pourquoi m\u00e9langer les deux types ?</p> <ul> <li>AR Raycast pour toucher les plans r\u00e9els d\u00e9tect\u00e9s</li> <li>Physics Raycast classique pour toucher les cubes virtuels (qui ont des colliders)</li> </ul>"},{"location":"exercice_adaptation_ar/#etape-4-test-en-simulation","title":"\u00c9tape 4 : Test en simulation","text":""},{"location":"exercice_adaptation_ar/#41-lancer-la-simulation","title":"4.1 : Lancer la simulation","text":"<ol> <li>Appuyez sur Play</li> <li> <p>Vous devriez voir :</p> </li> <li> <p>L'environnement de simulation (pi\u00e8ce 3D)</p> </li> <li>Des grilles vertes sur le sol (plans d\u00e9tect\u00e9s)</li> </ol>"},{"location":"exercice_adaptation_ar/#42-tester-le-placement","title":"4.2 : Tester le placement","text":"<ol> <li>Clic gauche sur une surface verte \u2192 Un cube devrait appara\u00eetre</li> <li>Utilisez les touches 1-5 pour changer de couleur</li> <li>Placez plusieurs cubes de diff\u00e9rentes couleurs</li> </ol>"},{"location":"exercice_adaptation_ar/#43-tester-la-navigation","title":"4.3 : Tester la navigation","text":"<ul> <li>Clic droit + souris : Regarder autour</li> <li>WASD : Se d\u00e9placer</li> <li>Observez les cubes depuis diff\u00e9rents angles</li> </ul>"},{"location":"exercice_adaptation_ar/#44-verifications","title":"4.4 : V\u00e9rifications","text":"<p>\u2705 Les cubes apparaissent uniquement sur les plans verts ? \u2705 La suppression fonctionne toujours (si impl\u00e9ment\u00e9e) ? \u2705 Le changement de couleur fonctionne ?</p>"},{"location":"exercice_adaptation_ar/#etape-5-amelioration-feedback-visuel","title":"\u00c9tape 5 : Am\u00e9lioration - Feedback visuel","text":""},{"location":"exercice_adaptation_ar/#51-ajouter-un-indicateur-de-pret","title":"5.1 : Ajouter un indicateur de \"pr\u00eat\"","text":"<p>Cr\u00e9ez un nouveau script <code>ARStatusFeedback.cs</code> :</p> <pre><code>using UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.XR.ARFoundation;\n\npublic class ARStatusFeedback : MonoBehaviour\n{\n    [SerializeField] private ARPlaneManager planeManager;\n    [SerializeField] private Text statusText; // N\u00e9cessite un UI Text\n\n    private int planesCount = 0;\n\n    void Update()\n    {\n        // Compter les plans d\u00e9tect\u00e9s\n        planesCount = planeManager.trackables.count;\n\n        if (planesCount == 0)\n        {\n            statusText.text = \"Recherche de surfaces...\";\n            statusText.color = Color.yellow;\n        }\n        else\n        {\n            statusText.text = $\"Pr\u00eat ! {planesCount} surface(s) d\u00e9tect\u00e9e(s)\";\n            statusText.color = Color.green;\n        }\n    }\n}\n</code></pre>"},{"location":"exercice_adaptation_ar/#52-creer-lui","title":"5.2 : Cr\u00e9er l'UI","text":"<ol> <li>Clic droit dans Hierarchy \u2192 UI \u2192 Text - TextMeshPro    (Si demand\u00e9, importez TMP Essentials)</li> <li>Renommez le Text en \"StatusText\"</li> <li> <p>Configurez le texte :</p> </li> <li> <p>Font Size : 24</p> </li> <li>Alignment : Center</li> <li> <p>Position en haut de l'\u00e9cran</p> </li> <li> <p>Cr\u00e9ez un GameObject vide \"ARManager\"</p> </li> <li>Attachez le script <code>ARStatusFeedback</code></li> <li> <p>Assignez les r\u00e9f\u00e9rences :</p> </li> <li> <p>AR Plane Manager (depuis XR Origin)</p> </li> <li>Status Text</li> </ol> <p>Testez : Le texte devrait indiquer combien de surfaces sont d\u00e9tect\u00e9es.</p>"},{"location":"exercice_adaptation_ar/#etape-6-gerer-les-cubes-sur-differents-types-de-plans","title":"\u00c9tape 6 : G\u00e9rer les cubes sur diff\u00e9rents types de plans","text":""},{"location":"exercice_adaptation_ar/#61-detecter-le-type-de-plan","title":"6.1 : D\u00e9tecter le type de plan","text":"<p>Modifiez votre m\u00e9thode de placement pour r\u00e9agir au type de plan :</p> <pre><code>private void OnTap(InputAction.CallbackContext context)\n{\n    Vector2 touchPosition = controles.Player.Point.ReadValue&lt;Vector2&gt;();\n    List&lt;ARRaycastHit&gt; hits = new List&lt;ARRaycastHit&gt;();\n\n    if (arRaycastManager.Raycast(touchPosition, hits, TrackableType.PlaneWithinPolygon))\n    {\n        Pose hitPose = hits[0].pose;\n\n        // Obtenir le plan touch\u00e9\n        ARPlane plane = hits[0].trackable as ARPlane;\n\n        // Adapter selon le type de plan\n        Vector3 position = hitPose.position;\n\n        if (plane.alignment == PlaneAlignment.HorizontalUp)\n        {\n            // Sol ou table - position normale\n            position += Vector3.up * 0.25f; // L\u00e9g\u00e8rement au-dessus\n        }\n        else if (plane.alignment == PlaneAlignment.Vertical)\n        {\n            // Mur - peut-\u00eatre coller au mur ?\n            position += plane.normal * 0.1f; // L\u00e9g\u00e8rement devant le mur\n        }\n\n        GameObject nouveauCube = Instantiate(cubePrefab, position, Quaternion.identity);\n\n        // Appliquer couleur\n        Renderer renderer = nouveauCube.GetComponent&lt;Renderer&gt;();\n        if (renderer != null)\n        {\n            renderer.material.color = couleurActuelle;\n        }\n\n        nouveauCube.tag = \"Cube\";\n\n        Debug.Log($\"Cube plac\u00e9 sur : {plane.alignment}\");\n    }\n}\n</code></pre>"},{"location":"exercice_adaptation_ar/#62-configuration-pour-tester","title":"6.2 : Configuration pour tester","text":"<p>Dans AR Plane Manager :</p> <ul> <li>Changez Detection Mode \u00e0 Everything</li> </ul> <p>Cela permet de d\u00e9tecter les murs en plus du sol.</p>"},{"location":"exercice_adaptation_ar/#etape-7-defis-supplementaires","title":"\u00c9tape 7 : D\u00e9fis suppl\u00e9mentaires","text":""},{"location":"exercice_adaptation_ar/#defi-1-utiliser-les-ancres","title":"D\u00e9fi 1 : Utiliser les ancres","text":"<p>Les ancres sont importantes pour que les objets restent stables.</p> <p>Indice : Cr\u00e9ez une ancre \u00e0 chaque placement :</p> <pre><code>// Apr\u00e8s avoir cr\u00e9\u00e9 le cube\nARAnchor anchor = hits[0].trackable.gameObject.AddComponent&lt;ARAnchor&gt;();\nnouveauCube.transform.parent = anchor.transform;\n</code></pre>"},{"location":"exercice_adaptation_ar/#defi-2-limiter-le-placement-aux-surfaces-horizontales","title":"D\u00e9fi 2 : Limiter le placement aux surfaces horizontales","text":"<p>Modifiez le raycast pour ignorer les murs :</p> <pre><code>if (arRaycastManager.Raycast(touchPosition, hits, \n    TrackableType.PlaneWithinPolygon))\n{\n    ARPlane plane = hits[0].trackable as ARPlane;\n\n    // Placer uniquement sur surfaces horizontales\n    if (plane.alignment == PlaneAlignment.HorizontalUp)\n    {\n        // Placer le cube\n    }\n    else\n    {\n        Debug.Log(\"Placement uniquement sur surfaces horizontales\");\n    }\n}\n</code></pre>"},{"location":"exercice_adaptation_ar/#defi-3-preview-avant-placement","title":"D\u00e9fi 3 : Preview avant placement","text":"<p>Affichez un cube fant\u00f4me qui suit le pointeur avant de confirmer le placement.</p> <p>\u00c9tapes sugg\u00e9r\u00e9es : 1. Cr\u00e9ez un cube semi-transparent qui suit le raycast 2. Au tap, transformez-le en cube permanent 3. Cr\u00e9ez un nouveau cube fant\u00f4me</p>"},{"location":"exercice_adaptation_ar/#defi-4-mode-peinture-continue","title":"D\u00e9fi 4 : Mode \"peinture continue\"","text":"<p>Permettez de placer des cubes en maintenant le doigt, pas seulement au tap.</p> <p>Indices : - Utilisez les \u00e9v\u00e9nements <code>started</code> et <code>canceled</code> - Ajoutez un d\u00e9lai entre chaque placement (0.1s)</p>"},{"location":"exercice_adaptation_ar/#recapitulatif-des-concepts-utilises","title":"R\u00e9capitulatif des concepts utilis\u00e9s","text":"<p>\u2705 AR Foundation : Framework unifi\u00e9 pour AR \u2705 XR Origin : Syst\u00e8me de coordonn\u00e9es AR \u2705 AR Session : Gestion de la session AR \u2705 AR Plane Manager : D\u00e9tection de plans \u2705 AR Raycast Manager : Raycasting sur plans AR \u2705 TrackableType : Filtrer ce que le raycast touche \u2705 Pose : Position + rotation en AR \u2705 PlaneAlignment : Type de plan (horizontal/vertical)  </p>"},{"location":"exercice_adaptation_ar/#differences-cles-avec-le-raycasting-3d","title":"Diff\u00e9rences cl\u00e9s avec le raycasting 3D","text":"Aspect Raycasting 3D Raycasting AR Cible Colliders Unity Plans d\u00e9tect\u00e9s par ARCore Manager Physics ARRaycastManager Hit type RaycastHit ARRaycastHit Position hit.point hit.pose.position"},{"location":"exercice_adaptation_ar/#remise-de-lexercice","title":"Remise de l'exercice","text":"<p>\u00c0 remettre :</p> <ol> <li>Lien Github du projet adapt\u00e9 en AR</li> <li>Captures d'\u00e9cran montrant :</li> <li>La sc\u00e8ne AR avec plans d\u00e9tect\u00e9s (grilles vertes)</li> <li>Plusieurs cubes de diff\u00e9rentes couleurs plac\u00e9s</li> <li>Le UI de feedback (si impl\u00e9ment\u00e9)</li> <li>Vid\u00e9o courte (30-60 secondes) d\u00e9montrant :</li> <li>Navigation dans la simulation</li> <li>Placement de cubes sur diff\u00e9rentes surfaces</li> <li>Changement de couleur</li> </ol> <p>Bonus : - Gestion des diff\u00e9rents types de plans (sol vs murs) - Syst\u00e8me de preview avant placement - Utilisation d'ancres - UI de feedback complet - Installation sur votre cellulaire et d\u00e9mo en flexant</p>"},{"location":"exercice_adaptation_ar/#questions-de-reflexion","title":"Questions de r\u00e9flexion","text":"<ol> <li>Quelle est la principale diff\u00e9rence entre <code>Physics.Raycast()</code> et <code>arRaycastManager.Raycast()</code> ?</li> <li>Pourquoi utilise-t-on <code>TrackableType.PlaneWithinPolygon</code> dans le raycast AR ?</li> <li>Dans quel cas pourrait-on avoir besoin de combiner les deux types de raycasting dans une m\u00eame app ?</li> <li>Que se passerait-il si on utilisait <code>hit.pose.rotation</code> au lieu de <code>Quaternion.identity</code> pour les cubes ?</li> <li>Pourquoi est-il important de tester en simulation avant de d\u00e9ployer sur appareil ?</li> </ol>"},{"location":"exercice_adaptation_ar/#depannage","title":"D\u00e9pannage","text":""},{"location":"exercice_adaptation_ar/#arraycastmanager-is-null","title":"\u274c \"ARRaycastManager is null\"","text":"<p>Cause : R\u00e9f\u00e9rence non assign\u00e9e</p> <p>Solution :</p> <ol> <li>V\u00e9rifiez que XR Origin a bien le composant AR Raycast Manager</li> <li>Glissez XR Origin dans le champ du script dans l'Inspector</li> </ol>"},{"location":"exercice_adaptation_ar/#le-raycast-ne-touche-jamais-rien","title":"\u274c Le raycast ne touche jamais rien","text":"<p>V\u00e9rifications :</p> <ol> <li>Les plans sont bien d\u00e9tect\u00e9s (grilles visibles) ?</li> <li>AR Raycast Manager est sur XR Origin ?</li> <li>Vous utilisez bien <code>TrackableType.PlaneWithinPolygon</code> ?</li> </ol>"},{"location":"exercice_adaptation_ar/#les-cubes-apparaissent-a-des-positions-etranges","title":"\u274c Les cubes apparaissent \u00e0 des positions \u00e9tranges","text":"<p>Cause possible : Confusion entre coordinate spaces</p> <p>Solution : Utilisez toujours <code>hits[0].pose.position</code> directement, sans transformation</p>"},{"location":"exercice_adaptation_ar/#namespace-xrarfoundation-could-not-be-found","title":"\u274c \"Namespace XR.ARFoundation could not be found\"","text":"<p>Cause : Packages AR non install\u00e9s</p> <p>Solution :</p> <ol> <li>V\u00e9rifiez Package Manager \u2192 AR Foundation install\u00e9</li> <li>Red\u00e9marrez Unity si n\u00e9cessaire</li> </ol>"},{"location":"exercice_raycasting_peinture3d/","title":"Exercice guid\u00e9 - Peinture 3D avec Raycasting","text":""},{"location":"exercice_raycasting_peinture3d/#objectifs-de-lexercice","title":"Objectifs de l'exercice","text":"<p>Dans cet exercice, vous allez cr\u00e9er une petite application de \"peinture 3D\" qui permet de :</p> <ol> <li>\u2705 Placer des cubes color\u00e9s en cliquant dans l'espace 3D</li> <li>\u2705 Supprimer des cubes avec le clic droit</li> <li>\u2705 Ignorer des objets en mouvement qui ne doivent pas interf\u00e9rer avec le placement</li> <li>\u2705 Changer la couleur des cubes \u00e0 placer</li> </ol> <p>Dur\u00e9e approximative : 45-60 minutes</p>"},{"location":"exercice_raycasting_peinture3d/#etape-1-configuration-de-la-scene","title":"\u00c9tape 1 : Configuration de la sc\u00e8ne","text":""},{"location":"exercice_raycasting_peinture3d/#11-creer-un-nouveau-projet-unity","title":"1.1 Cr\u00e9er un nouveau projet Unity","text":"<ol> <li>Ouvrez Unity Hub</li> <li>Cr\u00e9ez un nouveau projet 3D</li> <li>Nommez-le <code>RaycastingExercice</code></li> </ol>"},{"location":"exercice_raycasting_peinture3d/#12-preparer-la-scene","title":"1.2 Pr\u00e9parer la sc\u00e8ne","text":"<ol> <li> <p>Cr\u00e9er un sol :</p> </li> <li> <p>GameObject \u2192 3D Object \u2192 Plane</p> </li> <li>Renommez-le \"Sol\"</li> <li> <p>Scale : (5, 1, 5) pour avoir une grande surface</p> </li> <li> <p>Ajuster la cam\u00e9ra :</p> </li> <li> <p>S\u00e9lectionnez Main Camera</p> </li> <li>Position : (0, 10, -10)</li> <li>Rotation : (45, 0, 0)</li> <li>Vous devriez voir le sol en perspective</li> </ol>"},{"location":"exercice_raycasting_peinture3d/#13-creer-un-prefab-de-cube","title":"1.3 Cr\u00e9er un prefab de cube","text":"<ol> <li>Scale : (0.5, 0.5, 0.5) pour faire un petit cube</li> <li>Renommez le prefab \"CubePrefab\"</li> </ol>"},{"location":"exercice_raycasting_peinture3d/#etape-2-script-de-placement-de-base","title":"\u00c9tape 2 : Script de placement de base","text":""},{"location":"exercice_raycasting_peinture3d/#21-creer-le-script-principal","title":"2.1 Cr\u00e9er le script principal","text":"<ol> <li>Dans le dossier Scripts</li> <li>Nommez-le <code>PlacementRaycast</code></li> <li>Double-cliquez pour l'ouvrir dans votre \u00e9diteur de code</li> <li>Placer un CubePrefab \u00e0 l'endroit o\u00f9 un rayon frappe le Sol, \u00e0 chaque clique.</li> <li>Ajouter un param\u00e8tre de couleur configurable pour la couleur du cube</li> </ol>"},{"location":"exercice_raycasting_peinture3d/#22-configurer-le-script","title":"2.2 Configurer le script","text":"<ol> <li>Cr\u00e9ez un GameObject vide : GameObject \u2192 Create Empty</li> <li>Renommez-le \"Utilisateur\"</li> <li>Attachez le script <code>PlacementRaycast</code> au GameManager</li> <li>Dans l'Inspector, glissez le CubePrefab dans le champ <code>Cube Prefab</code></li> </ol> <p>Testez : Lancez le jeu et cliquez sur le sol. Des cubes rouges devraient appara\u00eetre!</p>"},{"location":"exercice_raycasting_peinture3d/#etape-3-ajouter-la-suppression-de-cubes","title":"\u00c9tape 3 : Ajouter la suppression de cubes","text":""},{"location":"exercice_raycasting_peinture3d/#31-modifier-le-script-pour-gerer-le-clic-droit","title":"3.1 Modifier le script pour g\u00e9rer le clic droit","text":"<ol> <li>Utilisez une nouvelle Action configur\u00e9e pour d\u00e9tecter le clique de droite</li> <li>Utilisez les tag pour d\u00e9tecter si le GameObject touch\u00e9 est un cube</li> </ol> <p>Testez : Vous devriez pouvoir placer des cubes avec le clic gauche et les supprimer avec le clic droit!</p>"},{"location":"exercice_raycasting_peinture3d/#etape-4-systeme-de-selection-de-couleurs","title":"\u00c9tape 4 : Syst\u00e8me de s\u00e9lection de couleurs","text":""},{"location":"exercice_raycasting_peinture3d/#41-ajouter-des-touches-pour-changer-la-couleur","title":"4.1 Ajouter des touches pour changer la couleur","text":"<ol> <li>Cr\u00e9ez l'Action et les Binding n\u00e9cessaires pour d\u00e9tecter 5 touches diff\u00e9rentes</li> <li>Programmer l'\u00e9v\u00e9nement pour changer la couleur des cubes : rouge, vert, bleu, jaune, magenta</li> </ol> <p>Testez : Appuyez sur les touches 1-5 pour changer de couleur, puis placez des cubes!</p>"},{"location":"exercice_raycasting_peinture3d/#etape-5-bonification-ajouter-un-objet-en-mouvement-a-ignorer","title":"\u00c9tape 5 : BONIFICATION - Ajouter un objet en mouvement \u00e0 ignorer","text":"<p>C'est ici que nous appliquons les concepts de LayerMask.</p>"},{"location":"exercice_raycasting_peinture3d/#51-creer-un-objet-en-mouvement","title":"5.1 Cr\u00e9er un objet en mouvement","text":"<ol> <li>GameObject \u2192 3D Object \u2192 Sphere</li> <li>Renommez-la \"SphereEnMouvement\"</li> <li>Position : (0, 2, 0)</li> <li>Changez sa couleur pour la distinguer :</li> <li>S\u00e9lectionnez la sph\u00e8re</li> <li>Dans l'Inspector, sous Mesh Renderer \u2192 Materials \u2192 Element 0</li> <li>Changez la couleur en orange ou autre couleur distinctive</li> </ol>"},{"location":"exercice_raycasting_peinture3d/#52-creer-un-script-de-mouvement-simple","title":"5.2 Cr\u00e9er un script de mouvement simple","text":"<ol> <li>Create \u2192 C# Script \u2192 <code>MouvementSimple</code></li> <li>Attachez ce script \u00e0 la SphereEnMouvement</li> <li>Testez : la sph\u00e8re devrait bouger de gauche \u00e0 droite</li> </ol>"},{"location":"exercice_raycasting_peinture3d/#53-creer-un-layer-ignorable","title":"5.3 Cr\u00e9er un Layer \"Ignorable\"","text":"<ol> <li>S\u00e9lectionnez la SphereEnMouvement</li> <li>En haut de l'Inspector, cliquez sur Layer \u2192 Add Layer...</li> <li>Dans un slot vide (par exemple User Layer 6), \u00e9crivez \"Ignorable\"</li> <li>Retournez \u00e0 la SphereEnMouvement</li> <li>Changez son Layer pour \"Ignorable\"</li> </ol>"},{"location":"exercice_raycasting_peinture3d/#54-modifier-le-script-de-placement-pour-ignorer-ce-layer","title":"5.4 Modifier le script de placement pour ignorer ce layer","text":"<p>Modifiez votre classe <code>PlacementRaycast</code></p>"},{"location":"exercice_raycasting_peinture3d/#55-configurer-le-layermask-dans-linspector","title":"5.5 Configurer le LayerMask dans l'Inspector","text":"<ol> <li>S\u00e9lectionnez le GameManager</li> <li>Dans l'Inspector, trouvez le champ Layer Mask</li> <li>Cliquez dessus pour voir la liste des layers</li> <li>D\u00e9cochez \"Ignorable\"</li> <li>Laissez tout le reste coch\u00e9 (Default, etc.)</li> </ol> <p>Testez :  - La sph\u00e8re orange devrait bouger - Si vous cliquez dessus, rien ne se passe (elle est ignor\u00e9e!) - Vous pouvez toujours placer des cubes sur le sol</p>"},{"location":"exercice_raycasting_peinture3d/#etape-6-ameliorations-visuelles-optionnelles","title":"\u00c9tape 6 : Am\u00e9liorations visuelles (optionnelles)","text":""},{"location":"exercice_raycasting_peinture3d/#61-visualiser-le-rayon","title":"6.1 Visualiser le rayon","text":"<p>Ajoutez la visualisation du rayon.</p>"},{"location":"exercice_raycasting_peinture3d/#62-indicateur-de-couleur-actuelle","title":"6.2 Indicateur de couleur actuelle","text":"<p>Cr\u00e9ez un nouveau script <code>IndicateurCouleur.cs</code></p> <p>Puis :</p> <ol> <li>Cr\u00e9ez un petit cube dans la sc\u00e8ne (GameObject \u2192 3D Object \u2192 Cube)</li> <li>Positionnez-le dans un coin de l'\u00e9cran visible (ex: Position (3, 1, 0), Scale (0.3, 0.3, 0.3))</li> <li>Attachez le script <code>IndicateurCouleur</code> au cube</li> <li>Utilisez une technique au choix pour que le cube soit de la couleur actuelle de placement des cubes</li> </ol> <p>Maintenant, ce petit cube montre la couleur active!</p>"},{"location":"exercice_raycasting_peinture3d/#etape-7-defis-supplementaires","title":"\u00c9tape 7 : D\u00e9fis suppl\u00e9mentaires","text":"<p>Si vous terminez en avance, essayez ces am\u00e9liorations :</p>"},{"location":"exercice_raycasting_peinture3d/#defi-1-ajuster-la-hauteur-des-cubes","title":"D\u00e9fi 1 : Ajuster la hauteur des cubes","text":"<p>Modifiez le placement pour que les cubes soient l\u00e9g\u00e8rement au-dessus de la surface au lieu d'\u00eatre parfaitement align\u00e9s :</p> <pre><code>Vector3 positionAjustee = hit.point + hit.normal * 0.25f; // 0.25 unit\u00e9 au-dessus\nGameObject nouveauCube = Instantiate(cubePrefab, positionAjustee, rotation);\n</code></pre>"},{"location":"exercice_raycasting_peinture3d/#defi-2-limiter-le-nombre-de-cubes","title":"D\u00e9fi 2 : Limiter le nombre de cubes","text":"<p>Ajoutez une limite au nombre de cubes plac\u00e9s.</p>"},{"location":"exercice_raycasting_peinture3d/#defi-3-ajouter-un-deuxieme-objet-en-mouvement","title":"D\u00e9fi 3 : Ajouter un deuxi\u00e8me objet en mouvement","text":"<p>Cr\u00e9ez une autre sph\u00e8re avec un mouvement vertical cette fois.</p>"},{"location":"exercice_raycasting_peinture3d/#defi-4-effet-de-particules-au-placement","title":"D\u00e9fi 4 : Effet de particules au placement","text":"<p>Ajoutez un effet de particules au sol quand un cube est plac\u00e9.</p>"},{"location":"exercice_raycasting_peinture3d/#recapitulatif-des-concepts-utilises","title":"R\u00e9capitulatif des concepts utilis\u00e9s","text":"<p>\u2705 Raycasting : D\u00e9tecter o\u00f9 l'utilisateur clique \u2705 RaycastHit : Obtenir des informations sur la collision (point, normale) \u2705 Quaternion.identity : Pas de rotation \u2705 Quaternion.FromToRotation : Aligner avec la normale de surface \u2705 LayerMask : Filtrer les objets que le raycast peut toucher \u2705 Instantiate / Destroy : Cr\u00e9er et supprimer des objets dynamiquement \u2705 \u00c9v\u00e9nement Performed : D\u00e9tecter les clics \u2705 Debug.Log / Debug.DrawRay : D\u00e9boguer et visualiser  </p>"},{"location":"exercice_raycasting_peinture3d/#questions-de-reflexion","title":"Questions de r\u00e9flexion","text":"<ol> <li>Que se passerait-il si vous enleviez le Collider du sol?</li> <li>Comment pourriez-vous modifier le code pour placer des cubes uniquement sur certaines surfaces (ex: seulement sur le sol, pas sur d'autres cubes)?</li> <li>Quel est l'avantage d'utiliser un LayerMask par rapport \u00e0 v\u00e9rifier le nom de l'objet avec <code>if (hit.collider.gameObject.name == \"...\")</code>?</li> </ol>"},{"location":"exercice_raycasting_peinture3d/#remise-de-lexercice","title":"Remise de l'exercice","text":"<p>\u00c0 remettre : - Lien public vers le d\u00e9p\u00f4t Github du projet - Captures d'\u00e9cran montrant :   - Des cubes de diff\u00e9rentes couleurs plac\u00e9s   - La sph\u00e8re en mouvement qui est ignor\u00e9e   - La vue Scene avec les rayons visibles (Debug.DrawRay)</p>"},{"location":"exercice_raycasting_peinture3d_sol/","title":"Exercice guid\u00e9 - Peinture 3D avec Raycasting","text":""},{"location":"exercice_raycasting_peinture3d_sol/#objectifs-de-lexercice","title":"Objectifs de l'exercice","text":"<p>Dans cet exercice, vous allez cr\u00e9er une petite application de \"peinture 3D\" qui permet de :</p> <ol> <li>\u2705 Placer des cubes color\u00e9s en cliquant dans l'espace 3D</li> <li>\u2705 Supprimer des cubes avec le clic droit</li> <li>\u2705 Ignorer des objets en mouvement qui ne doivent pas interf\u00e9rer avec le placement</li> <li>\u2705 Changer la couleur des cubes \u00e0 placer</li> </ol> <p>Dur\u00e9e approximative : 45-60 minutes</p>"},{"location":"exercice_raycasting_peinture3d_sol/#etape-1-configuration-de-la-scene","title":"\u00c9tape 1 : Configuration de la sc\u00e8ne","text":""},{"location":"exercice_raycasting_peinture3d_sol/#11-creer-un-nouveau-projet-unity","title":"1.1 Cr\u00e9er un nouveau projet Unity","text":"<ol> <li>Ouvrez Unity Hub</li> <li>Cr\u00e9ez un nouveau projet 3D (Built-in Render Pipeline)</li> <li>Nommez-le <code>RaycastingExercice</code></li> </ol>"},{"location":"exercice_raycasting_peinture3d_sol/#12-preparer-la-scene","title":"1.2 Pr\u00e9parer la sc\u00e8ne","text":"<ol> <li> <p>Cr\u00e9er un sol :</p> </li> <li> <p>GameObject \u2192 3D Object \u2192 Plane</p> </li> <li>Renommez-le \"Sol\"</li> <li> <p>Scale : (5, 1, 5) pour avoir une grande surface</p> </li> <li> <p>Ajuster la cam\u00e9ra :</p> </li> <li> <p>S\u00e9lectionnez Main Camera</p> </li> <li>Position : (0, 10, -10)</li> <li>Rotation : (45, 0, 0)</li> <li>Vous devriez voir le sol en perspective</li> </ol>"},{"location":"exercice_raycasting_peinture3d_sol/#13-creer-un-prefab-de-cube","title":"1.3 Cr\u00e9er un prefab de cube","text":"<ol> <li>Scale : (0.5, 0.5, 0.5) pour faire un petit cube</li> <li>Renommez le prefab \"CubePrefab\"</li> </ol>"},{"location":"exercice_raycasting_peinture3d_sol/#etape-2-script-de-placement-de-base","title":"\u00c9tape 2 : Script de placement de base","text":""},{"location":"exercice_raycasting_peinture3d_sol/#21-creer-le-script-principal","title":"2.1 Cr\u00e9er le script principal","text":"<ol> <li>Dans le dossier Scripts</li> <li>Nommez-le <code>PlacementRaycast</code></li> <li>Double-cliquez pour l'ouvrir dans votre \u00e9diteur de code</li> </ol>"},{"location":"exercice_raycasting_peinture3d_sol/#22-code-de-base-pour-placer-des-cubes","title":"2.2 Code de base pour placer des cubes","text":"<pre><code>using UnityEngine;\n\npublic class PlacementRaycast : MonoBehaviour\n{\n    [Header(\"Prefabs\")]\n    public GameObject cubePrefab;\n\n    [Header(\"Param\u00e8tres\")]\n    public Color couleurActuelle = Color.red;\n\n    void Update()\n    {\n        // Clic gauche : placer un cube\n        if (Input.GetMouseButtonDown(0))\n        {\n            PlacerCube();\n        }\n    }\n\n    void PlacerCube()\n    {\n        // Cr\u00e9er un rayon depuis la cam\u00e9ra vers la position de la souris\n        Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);\n        RaycastHit hit;\n\n        // Lancer le rayon\n        if (Physics.Raycast(ray, out hit))\n        {\n            // Cr\u00e9er le cube au point d'impact\n            GameObject nouveauCube = Instantiate(cubePrefab, hit.point, Quaternion.identity);\n\n            // Appliquer la couleur\n            Renderer renderer = nouveauCube.GetComponent&lt;Renderer&gt;();\n            if (renderer != null)\n            {\n                renderer.material.color = couleurActuelle;\n            }\n\n            // Nommer le cube pour faciliter le d\u00e9bogage\n            nouveauCube.name = \"Cube_\" + Time.time;\n        }\n    }\n}\n</code></pre>"},{"location":"exercice_raycasting_peinture3d_sol/#23-configurer-le-script","title":"2.3 Configurer le script","text":"<ol> <li>Cr\u00e9ez un GameObject vide : GameObject \u2192 Create Empty</li> <li>Renommez-le \"GameManager\"</li> <li>Attachez le script <code>PlacementRaycast</code> au GameManager</li> <li>Dans l'Inspector, glissez le CubePrefab dans le champ <code>Cube Prefab</code></li> </ol> <p>Testez : Lancez le jeu et cliquez sur le sol. Des cubes rouges devraient appara\u00eetre!</p>"},{"location":"exercice_raycasting_peinture3d_sol/#etape-3-ajouter-la-suppression-de-cubes","title":"\u00c9tape 3 : Ajouter la suppression de cubes","text":""},{"location":"exercice_raycasting_peinture3d_sol/#31-modifier-le-script-pour-gerer-le-clic-droit","title":"3.1 Modifier le script pour g\u00e9rer le clic droit","text":"<p>Ajoutez cette m\u00e9thode dans votre script :</p> <pre><code>void Update()\n{\n    // Clic gauche : placer un cube\n    if (Input.GetMouseButtonDown(0))\n    {\n        PlacerCube();\n    }\n\n    // Clic droit : supprimer un cube\n    if (Input.GetMouseButtonDown(1))\n    {\n        SupprimerCube();\n    }\n}\n\nvoid SupprimerCube()\n{\n    Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);\n    RaycastHit hit;\n\n    if (Physics.Raycast(ray, out hit))\n    {\n        // V\u00e9rifier si l'objet touch\u00e9 est un cube plac\u00e9\n        if (hit.collider.gameObject.name.StartsWith(\"Cube_\"))\n        {\n            Destroy(hit.collider.gameObject);\n            Debug.Log(\"Cube supprim\u00e9!\");\n        }\n        else\n        {\n            Debug.Log(\"Ce n'est pas un cube plac\u00e9, impossible de le supprimer.\");\n        }\n    }\n}\n</code></pre> <p>Testez : Vous devriez pouvoir placer des cubes avec le clic gauche et les supprimer avec le clic droit!</p>"},{"location":"exercice_raycasting_peinture3d_sol/#etape-4-systeme-de-selection-de-couleurs","title":"\u00c9tape 4 : Syst\u00e8me de s\u00e9lection de couleurs","text":""},{"location":"exercice_raycasting_peinture3d_sol/#41-ajouter-des-touches-pour-changer-la-couleur","title":"4.1 Ajouter des touches pour changer la couleur","text":"<p>Ajoutez cette m\u00e9thode \u00e0 votre script :</p> <pre><code>void Update()\n{\n    // Clic gauche : placer un cube\n    if (Input.GetMouseButtonDown(0))\n    {\n        PlacerCube();\n    }\n\n    // Clic droit : supprimer un cube\n    if (Input.GetMouseButtonDown(1))\n    {\n        SupprimerCube();\n    }\n\n    // Changer la couleur avec les touches num\u00e9riques\n    GererChangementCouleur();\n}\n\nvoid GererChangementCouleur()\n{\n    if (Input.GetKeyDown(KeyCode.Alpha1))\n    {\n        couleurActuelle = Color.red;\n        Debug.Log(\"Couleur : Rouge\");\n    }\n    else if (Input.GetKeyDown(KeyCode.Alpha2))\n    {\n        couleurActuelle = Color.blue;\n        Debug.Log(\"Couleur : Bleu\");\n    }\n    else if (Input.GetKeyDown(KeyCode.Alpha3))\n    {\n        couleurActuelle = Color.green;\n        Debug.Log(\"Couleur : Vert\");\n    }\n    else if (Input.GetKeyDown(KeyCode.Alpha4))\n    {\n        couleurActuelle = Color.yellow;\n        Debug.Log(\"Couleur : Jaune\");\n    }\n    else if (Input.GetKeyDown(KeyCode.Alpha5))\n    {\n        couleurActuelle = Color.magenta;\n        Debug.Log(\"Couleur : Magenta\");\n    }\n}\n</code></pre> <p>Testez : Appuyez sur les touches 1-5 pour changer de couleur, puis placez des cubes!</p>"},{"location":"exercice_raycasting_peinture3d_sol/#etape-5-bonification-ajouter-un-objet-en-mouvement-a-ignorer","title":"\u00c9tape 5 : BONIFICATION - Ajouter un objet en mouvement \u00e0 ignorer","text":"<p>C'est ici que nous appliquons les concepts de LayerMask!</p>"},{"location":"exercice_raycasting_peinture3d_sol/#51-creer-un-objet-en-mouvement","title":"5.1 Cr\u00e9er un objet en mouvement","text":"<ol> <li>GameObject \u2192 3D Object \u2192 Sphere</li> <li>Renommez-la \"SphereEnMouvement\"</li> <li>Position : (0, 2, 0)</li> <li>Changez sa couleur pour la distinguer :</li> <li>S\u00e9lectionnez la sph\u00e8re</li> <li>Dans l'Inspector, sous Mesh Renderer \u2192 Materials \u2192 Element 0</li> <li>Changez la couleur en orange ou autre couleur distinctive</li> </ol>"},{"location":"exercice_raycasting_peinture3d_sol/#52-creer-un-script-de-mouvement-simple","title":"5.2 Cr\u00e9er un script de mouvement simple","text":"<ol> <li>Create \u2192 C# Script \u2192 <code>MouvementSimple</code></li> <li>Ouvrez le script :</li> </ol> <pre><code>using UnityEngine;\n\npublic class MouvementSimple : MonoBehaviour\n{\n    [Header(\"Type de mouvement\")]\n    public bool mouvementHorizontal = true;\n\n    [Header(\"Param\u00e8tres\")]\n    public float amplitude = 5f;  // Distance du mouvement\n    public float vitesse = 2f;    // Vitesse du mouvement\n\n    private Vector3 positionInitiale;\n\n    void Start()\n    {\n        positionInitiale = transform.position;\n    }\n\n    void Update()\n    {\n        if (mouvementHorizontal)\n        {\n            // Mouvement lat\u00e9ral (gauche-droite)\n            float x = positionInitiale.x + Mathf.Sin(Time.time * vitesse) * amplitude;\n            transform.position = new Vector3(x, positionInitiale.y, positionInitiale.z);\n        }\n        else\n        {\n            // Mouvement vertical (haut-bas)\n            float y = positionInitiale.y + Mathf.Sin(Time.time * vitesse) * amplitude;\n            transform.position = new Vector3(positionInitiale.x, y, positionInitiale.z);\n        }\n    }\n}\n</code></pre> <ol> <li>Attachez ce script \u00e0 la SphereEnMouvement</li> <li>Testez : la sph\u00e8re devrait bouger de gauche \u00e0 droite</li> </ol>"},{"location":"exercice_raycasting_peinture3d_sol/#53-creer-un-layer-ignorable","title":"5.3 Cr\u00e9er un Layer \"Ignorable\"","text":"<ol> <li>S\u00e9lectionnez la SphereEnMouvement</li> <li>En haut de l'Inspector, cliquez sur Layer \u2192 Add Layer...</li> <li>Dans un slot vide (par exemple User Layer 6), \u00e9crivez \"Ignorable\"</li> <li>Retournez \u00e0 la SphereEnMouvement</li> <li>Changez son Layer pour \"Ignorable\"</li> </ol>"},{"location":"exercice_raycasting_peinture3d_sol/#54-modifier-le-script-de-placement-pour-ignorer-ce-layer","title":"5.4 Modifier le script de placement pour ignorer ce layer","text":"<p>Modifiez votre classe <code>PlacementRaycast</code> :</p> <pre><code>using UnityEngine;\n\npublic class PlacementRaycast : MonoBehaviour\n{\n    [Header(\"Prefabs\")]\n    public GameObject cubePrefab;\n\n    [Header(\"Param\u00e8tres\")]\n    public Color couleurActuelle = Color.red;\n\n    [Header(\"Filtrage des collisions\")]\n    public LayerMask layerMask = ~0; // Par d\u00e9faut, tous les layers\n\n    void Update()\n    {\n        if (Input.GetMouseButtonDown(0))\n        {\n            PlacerCube();\n        }\n\n        if (Input.GetMouseButtonDown(1))\n        {\n            SupprimerCube();\n        }\n\n        GererChangementCouleur();\n    }\n\n    void PlacerCube()\n    {\n        Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);\n        RaycastHit hit;\n\n        // Utiliser le layerMask pour filtrer les collisions\n        if (Physics.Raycast(ray, out hit, Mathf.Infinity, layerMask))\n        {\n            // Aligner le cube avec la surface (bonus!)\n            Quaternion rotation = Quaternion.FromToRotation(Vector3.up, hit.normal);\n\n            GameObject nouveauCube = Instantiate(cubePrefab, hit.point, rotation);\n\n            Renderer renderer = nouveauCube.GetComponent&lt;Renderer&gt;();\n            if (renderer != null)\n            {\n                renderer.material.color = couleurActuelle;\n            }\n\n            nouveauCube.name = \"Cube_\" + Time.time;\n\n            Debug.Log(\"Cube plac\u00e9 sur : \" + hit.collider.gameObject.name);\n        }\n    }\n\n    void SupprimerCube()\n    {\n        Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);\n        RaycastHit hit;\n\n        // M\u00eame layerMask pour la suppression\n        if (Physics.Raycast(ray, out hit, Mathf.Infinity, layerMask))\n        {\n            if (hit.collider.gameObject.name.StartsWith(\"Cube_\"))\n            {\n                Destroy(hit.collider.gameObject);\n                Debug.Log(\"Cube supprim\u00e9!\");\n            }\n        }\n    }\n\n    void GererChangementCouleur()\n    {\n        if (Input.GetKeyDown(KeyCode.Alpha1))\n        {\n            couleurActuelle = Color.red;\n            Debug.Log(\"Couleur : Rouge\");\n        }\n        else if (Input.GetKeyDown(KeyCode.Alpha2))\n        {\n            couleurActuelle = Color.blue;\n            Debug.Log(\"Couleur : Bleu\");\n        }\n        else if (Input.GetKeyDown(KeyCode.Alpha3))\n        {\n            couleurActuelle = Color.green;\n            Debug.Log(\"Couleur : Vert\");\n        }\n        else if (Input.GetKeyDown(KeyCode.Alpha4))\n        {\n            couleurActuelle = Color.yellow;\n            Debug.Log(\"Couleur : Jaune\");\n        }\n        else if (Input.GetKeyDown(KeyCode.Alpha5))\n        {\n            couleurActuelle = Color.magenta;\n            Debug.Log(\"Couleur : Magenta\");\n        }\n    }\n}\n</code></pre>"},{"location":"exercice_raycasting_peinture3d_sol/#55-configurer-le-layermask-dans-linspector","title":"5.5 Configurer le LayerMask dans l'Inspector","text":"<ol> <li>S\u00e9lectionnez le GameManager</li> <li>Dans l'Inspector, trouvez le champ Layer Mask</li> <li>Cliquez dessus pour voir la liste des layers</li> <li>D\u00e9cochez \"Ignorable\"</li> <li>Laissez tout le reste coch\u00e9 (Default, etc.)</li> </ol> <p>Testez :  - La sph\u00e8re orange devrait bouger - Si vous cliquez dessus, rien ne se passe (elle est ignor\u00e9e!) - Vous pouvez toujours placer des cubes sur le sol</p>"},{"location":"exercice_raycasting_peinture3d_sol/#etape-6-ameliorations-visuelles-optionnelles","title":"\u00c9tape 6 : Am\u00e9liorations visuelles (optionnelles)","text":""},{"location":"exercice_raycasting_peinture3d_sol/#61-visualiser-le-rayon","title":"6.1 Visualiser le rayon","text":"<p>Ajoutez cette ligne dans <code>PlacerCube()</code> juste apr\u00e8s la cr\u00e9ation du rayon :</p> <pre><code>void PlacerCube()\n{\n    Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);\n\n    // Visualiser le rayon dans la Scene view\n    Debug.DrawRay(ray.origin, ray.direction * 100f, Color.yellow, 1f);\n\n    RaycastHit hit;\n    // ... reste du code\n}\n</code></pre>"},{"location":"exercice_raycasting_peinture3d_sol/#62-indicateur-de-couleur-actuelle","title":"6.2 Indicateur de couleur actuelle","text":"<p>Cr\u00e9ez un nouveau script <code>IndicateurCouleur.cs</code> :</p> <pre><code>using UnityEngine;\n\npublic class IndicateurCouleur : MonoBehaviour\n{\n    public PlacementRaycast placementScript;\n    private Renderer indicateurRenderer;\n\n    void Start()\n    {\n        indicateurRenderer = GetComponent&lt;Renderer&gt;();\n    }\n\n    void Update()\n    {\n        if (placementScript != null &amp;&amp; indicateurRenderer != null)\n        {\n            indicateurRenderer.material.color = placementScript.couleurActuelle;\n        }\n    }\n}\n</code></pre> <p>Puis : 1. Cr\u00e9ez un petit cube dans la sc\u00e8ne (GameObject \u2192 3D Object \u2192 Cube) 2. Positionnez-le dans un coin de l'\u00e9cran visible (ex: Position (3, 1, 0), Scale (0.3, 0.3, 0.3)) 3. Attachez le script <code>IndicateurCouleur</code> au cube 4. Assignez le GameManager dans le champ <code>Placement Script</code></p> <p>Maintenant, ce petit cube montre la couleur active!</p>"},{"location":"exercice_raycasting_peinture3d_sol/#etape-7-defis-supplementaires","title":"\u00c9tape 7 : D\u00e9fis suppl\u00e9mentaires","text":"<p>Si vous terminez en avance, essayez ces am\u00e9liorations :</p>"},{"location":"exercice_raycasting_peinture3d_sol/#defi-1-ajuster-la-hauteur-des-cubes","title":"D\u00e9fi 1 : Ajuster la hauteur des cubes","text":"<p>Modifiez le placement pour que les cubes soient l\u00e9g\u00e8rement au-dessus de la surface au lieu d'\u00eatre parfaitement align\u00e9s :</p> <pre><code>Vector3 positionAjustee = hit.point + hit.normal * 0.25f; // 0.25 unit\u00e9 au-dessus\nGameObject nouveauCube = Instantiate(cubePrefab, positionAjustee, rotation);\n</code></pre>"},{"location":"exercice_raycasting_peinture3d_sol/#defi-2-limiter-le-nombre-de-cubes","title":"D\u00e9fi 2 : Limiter le nombre de cubes","text":"<p>Ajoutez une limite au nombre de cubes plac\u00e9s :</p> <pre><code>[Header(\"Limites\")]\npublic int nombreMaxCubes = 20;\nprivate int nombreCubesActuels = 0;\n\nvoid PlacerCube()\n{\n    if (nombreCubesActuels &gt;= nombreMaxCubes)\n    {\n        Debug.LogWarning(\"Nombre maximum de cubes atteint!\");\n        return;\n    }\n\n    // ... reste du code de placement\n    nombreCubesActuels++;\n}\n\nvoid SupprimerCube()\n{\n    // ... code de suppression existant\n    nombreCubesActuels--;\n}\n</code></pre>"},{"location":"exercice_raycasting_peinture3d_sol/#defi-3-ajouter-un-deuxieme-objet-en-mouvement","title":"D\u00e9fi 3 : Ajouter un deuxi\u00e8me objet en mouvement","text":"<p>Cr\u00e9ez une autre sph\u00e8re avec un mouvement vertical cette fois : 1. Dupliquez SphereEnMouvement 2. Dans le script <code>MouvementSimple</code>, d\u00e9cochez <code>Mouvement Horizontal</code> 3. Assurez-vous qu'elle est aussi sur le layer \"Ignorable\"</p>"},{"location":"exercice_raycasting_peinture3d_sol/#defi-4-effet-de-particules-au-placement","title":"D\u00e9fi 4 : Effet de particules au placement","text":"<p>Ajoutez un effet visuel quand un cube est plac\u00e9 :</p> <pre><code>// Dans PlacerCube(), apr\u00e8s l'instantiation :\nParticleSystem particles = nouveauCube.GetComponent&lt;ParticleSystem&gt;();\nif (particles != null)\n{\n    particles.Play();\n}\n</code></pre> <p>Puis ajoutez un Particle System \u00e0 votre prefab de cube.</p>"},{"location":"exercice_raycasting_peinture3d_sol/#recapitulatif-des-concepts-utilises","title":"R\u00e9capitulatif des concepts utilis\u00e9s","text":"<p>\u2705 Raycasting : D\u00e9tecter o\u00f9 l'utilisateur clique \u2705 RaycastHit : Obtenir des informations sur la collision (point, normale) \u2705 Quaternion.identity : Pas de rotation \u2705 Quaternion.FromToRotation : Aligner avec la normale de surface \u2705 LayerMask : Filtrer les objets que le raycast peut toucher \u2705 Instantiate / Destroy : Cr\u00e9er et supprimer des objets dynamiquement \u2705 Input.GetMouseButtonDown : D\u00e9tecter les clics \u2705 Debug.Log / Debug.DrawRay : D\u00e9boguer et visualiser  </p>"},{"location":"exercice_raycasting_peinture3d_sol/#questions-de-reflexion","title":"Questions de r\u00e9flexion","text":"<ol> <li>Pourquoi utilisons-nous <code>Input.GetMouseButtonDown(0)</code> au lieu de <code>Input.GetMouseButton(0)</code>?</li> <li>Que se passerait-il si vous enleviez le Collider du sol?</li> <li>Comment pourriez-vous modifier le code pour placer des cubes uniquement sur certaines surfaces (ex: seulement sur le sol, pas sur d'autres cubes)?</li> <li>Quel est l'avantage d'utiliser un LayerMask par rapport \u00e0 v\u00e9rifier le nom de l'objet avec <code>if (hit.collider.gameObject.name == \"...\")</code>?</li> </ol>"},{"location":"exercice_raycasting_peinture3d_sol/#remise-de-lexercice","title":"Remise de l'exercice","text":"<p>\u00c0 remettre : - Projet Unity complet (zipp\u00e9) - Captures d'\u00e9cran montrant :   - Des cubes de diff\u00e9rentes couleurs plac\u00e9s   - La sph\u00e8re en mouvement qui est ignor\u00e9e   - La vue Scene avec les rayons visibles (Debug.DrawRay)</p> <p>Crit\u00e8res d'\u00e9valuation : - \u2705 Placement de cubes fonctionnel (3 points) - \u2705 Suppression de cubes fonctionnel (2 points) - \u2705 Changement de couleurs (2 points) - \u2705 Objet en mouvement correctement ignor\u00e9 (3 points) - \u2705 Code propre et comment\u00e9 (2 points) - \u2705 BONUS : D\u00e9fis suppl\u00e9mentaires (+1 point par d\u00e9fi)</p> <p>Date de remise : [\u00c0 d\u00e9terminer par le professeur]</p>"},{"location":"exercice_raycasting_peinture3d_sol/#prochaine-seance","title":"Prochaine s\u00e9ance","text":"<p>La semaine prochaine, nous allons appliquer ces concepts de raycasting dans le contexte de la r\u00e9alit\u00e9 augment\u00e9e avec ARCore. Vous verrez que le principe est exactement le m\u00eame, mais au lieu de cliquer sur un sol virtuel, nous d\u00e9tecterons des surfaces r\u00e9elles!</p> <p>F\u00e9licitations, vous ma\u00eetrisez maintenant le raycasting 3D! \ud83c\udf89</p>"},{"location":"intro_arcore/","title":"Introduction \u00e0 ARCore","text":""},{"location":"intro_arcore/#quest-ce-quarcore","title":"Qu'est-ce qu'ARCore?","text":"<p>ARCore est la plateforme de r\u00e9alit\u00e9 augment\u00e9e d\u00e9velopp\u00e9e par Google pour les appareils Android. Elle permet aux d\u00e9veloppeurs de cr\u00e9er des exp\u00e9riences AR en utilisant les capteurs et cam\u00e9ras d\u00e9j\u00e0 pr\u00e9sents sur les smartphones.</p> <p>Note : ARKit (Apple) fonctionne de mani\u00e8re tr\u00e8s similaire. Les concepts appris avec ARCore sont transf\u00e9rables \u00e0 ARKit.</p>"},{"location":"intro_arcore/#conception-dapplication","title":"Conception d'application","text":"<p>Design</p>"},{"location":"intro_arcore/#les-trois-piliers-darcore","title":"Les trois piliers d'ARCore","text":"<p>ARCore repose sur trois capacit\u00e9s fondamentales.</p>"},{"location":"intro_arcore/#1-tracking-de-mouvement-motion-tracking","title":"1. Tracking de mouvement (Motion Tracking)","text":"<p>ARCore utilise une technique appel\u00e9e SLAM (Simultaneous Localization and Mapping) pour comprendre o\u00f9 se trouve l'appareil dans l'espace.</p> <p>Comment \u00e7a fonctionne :</p> <ul> <li>La cam\u00e9ra capture des images continuellement</li> <li>ARCore identifie des points caract\u00e9ristiques (feature points) dans l'image</li> <li>En suivant ces points entre les images, ARCore calcule le d\u00e9placement de l'appareil</li> <li>R\u00e9sultat : ARCore sait o\u00f9 vous \u00eates et dans quelle direction vous regardez</li> </ul> <p>Analogie : Imaginez que vous fermez les yeux dans une pi\u00e8ce que vous connaissez. En touchant les meubles autour de vous, vous pouvez d\u00e9duire votre position et vos mouvements. ARCore fait la m\u00eame chose avec la cam\u00e9ra.</p> <p>Ce que \u00e7a permet :</p> <ul> <li>Placer un objet virtuel et le voir rester au m\u00eame endroit quand vous vous d\u00e9placez</li> <li>Marcher autour d'un objet 3D pour le voir sous tous les angles</li> <li>Cr\u00e9er une carte de l'environnement</li> </ul>"},{"location":"intro_arcore/#2-detection-de-plans-plane-detection","title":"2. D\u00e9tection de plans (Plane Detection)","text":"<p>ARCore analyse l'environnement pour d\u00e9tecter des surfaces planes comme les sols, tables, ou murs.</p> <p>Comment \u00e7a fonctionne :</p> <ul> <li>ARCore groupe les points caract\u00e9ristiques qui sont \u00e0 la m\u00eame hauteur</li> <li>Il forme des polygones qui repr\u00e9sentent des surfaces</li> <li>Ces surfaces sont continuellement mises \u00e0 jour pour gagner en pr\u00e9cision</li> </ul> <p>Types de plans d\u00e9tect\u00e9s :</p> Type Description Exemples Horizontal vers le haut Surface horizontale face vers le ciel Sol, table, bureau Horizontal vers le bas Surface horizontale face vers le sol Plafond Vertical Surface verticale Murs, portes <p>Ce que \u00e7a permet :</p> <ul> <li>Placer des objets de mani\u00e8re r\u00e9aliste sur les surfaces</li> <li>Savoir si une surface est un sol, un mur ou un plafond</li> <li>Cr\u00e9er des interactions qui respectent la g\u00e9om\u00e9trie r\u00e9elle</li> </ul> <p>Visualisation :</p> <p></p>"},{"location":"intro_arcore/#3-estimation-de-leclairage-light-estimation","title":"3. Estimation de l'\u00e9clairage (Light Estimation)","text":"<p>ARCore estime l'\u00e9clairage ambiant de l'environnement r\u00e9el pour que les objets virtuels aient un rendu coh\u00e9rent.</p> <p>Ce qui est estim\u00e9 :</p> <ul> <li>Intensit\u00e9 lumineuse : Est-ce lumineux ou sombre?</li> <li>Temp\u00e9rature de couleur : La lumi\u00e8re est-elle chaude (jaune) ou froide (bleue)?</li> <li>Direction principale : D'o\u00f9 vient la source de lumi\u00e8re?</li> </ul> <p>Ce que \u00e7a permet :</p> <ul> <li>Objets virtuels qui s'int\u00e8grent naturellement</li> <li>Ombres coh\u00e9rentes avec l'environnement</li> <li>R\u00e9flexions r\u00e9alistes sur les objets virtuels</li> </ul> <p>Exemple concret :</p> <p>Si vous \u00eates dans une pi\u00e8ce \u00e9clair\u00e9e par une lumi\u00e8re orange, vos objets virtuels auront aussi une teinte orange plut\u00f4t que d'\u00eatre blanc pur.</p>"},{"location":"intro_arcore/#concept-cle-les-ancres-anchors","title":"Concept cl\u00e9 : Les Ancres (Anchors)","text":"<p>Une ancre est un point fixe dans l'espace r\u00e9el auquel on attache des objets virtuels.</p>"},{"location":"intro_arcore/#pourquoi-les-ancres-sont-essentielles","title":"Pourquoi les ancres sont essentielles?","text":"<p>Sans ancre, ARCore doit recalculer constamment la position de chaque objet. Avec une ancre :</p> <ul> <li>\u2705 ARCore g\u00e8re automatiquement la position de l'ancre</li> <li>\u2705 Les objets restent stables m\u00eame quand vous bougez</li> <li>\u2705 La performance est optimis\u00e9e</li> </ul>"},{"location":"intro_arcore/#quand-creer-une-ancre","title":"Quand cr\u00e9er une ancre?","text":"<ul> <li>Placement d'objet : Quand l'utilisateur place un objet sur une surface</li> <li>Persistance : Pour que l'objet reste l\u00e0 entre les sessions</li> <li>Tracking pr\u00e9cis : Pour des objets qui doivent rester parfaitement align\u00e9s</li> </ul>"},{"location":"intro_arcore/#types-dancres","title":"Types d'ancres","text":"Type Description Usage Plane Anchor Ancr\u00e9 \u00e0 un plan d\u00e9tect\u00e9 Objets sur sol/table Feature Point Anchor Ancr\u00e9 \u00e0 un point caract\u00e9ristique Objets en l'air Cloud Anchor Ancr\u00e9 dans le cloud (partageable) Exp\u00e9riences multi-utilisateurs"},{"location":"intro_arcore/#le-cycle-de-vie-dune-session-ar","title":"Le cycle de vie d'une session AR","text":"<p>Comprendre comment fonctionne une session AR est crucial pour bien programmer.</p>"},{"location":"intro_arcore/#1-initialisation","title":"1. Initialisation","text":"<pre><code>D\u00e9marrage de l'app\n    \u00e2\u2020\"\nARCore s'initialise\n    \u00e2\u2020\"\nCam\u00e9ra activ\u00e9e\n</code></pre>"},{"location":"intro_arcore/#2-phase-de-tracking","title":"2. Phase de tracking","text":"<pre><code>[Tracking insuffisant]  \u00e2\u2020'  Demander \u00e0 l'utilisateur de bouger\n    \u00e2\u2020\"\n[Tracking limit\u00e9]       \u00e2\u2020'  D\u00e9tection de plans en cours\n    \u00e2\u2020\"\n[Tracking normal]       \u00e2\u2020'  Pr\u00eat pour placement d'objets\n</code></pre>"},{"location":"intro_arcore/#3-etats-du-tracking","title":"3. \u00c9tats du tracking","text":"\u00c9tat Signification Action recommand\u00e9e None ARCore non initialis\u00e9 Attendre Limited Tracking insuffisant Afficher instructions \u00e0 l'utilisateur Tracking Tout fonctionne Autoriser interactions"},{"location":"intro_arcore/#4-gestion-des-interruptions","title":"4. Gestion des interruptions","text":"<ul> <li>App en arri\u00e8re-plan : Session en pause</li> <li>Cam\u00e9ra bloqu\u00e9e : Tracking perdu</li> <li>Retour \u00e0 l'app : Session reprend (ou recommence)</li> </ul>"},{"location":"intro_arcore/#systeme-de-coordonnees","title":"Syst\u00e8me de coordonn\u00e9es","text":"<p>ARCore utilise un syst\u00e8me de coordonn\u00e9es diff\u00e9rent :</p> <p></p> <ul> <li>Origine : Position de l'appareil au d\u00e9marrage</li> <li>Y+ : Vers le haut (gravit\u00e9 invers\u00e9e)</li> <li>Z+ : Direction o\u00f9 regarde la cam\u00e9ra au d\u00e9marrage</li> <li>X+ : Droite de la cam\u00e9ra</li> </ul> <p>Important : Les objets sont plac\u00e9s en m\u00e8tres r\u00e9els, pas en unit\u00e9s Unity arbitraires.</p>"},{"location":"intro_arcore/#ar-foundation-le-pont-entre-unity-et-arcore","title":"AR Foundation : Le pont entre Unity et ARCore","text":"<p>AR Foundation est une couche d'abstraction cr\u00e9\u00e9e par Unity qui unifie ARCore (Android) et ARKit (iOS).</p>"},{"location":"intro_arcore/#architecture","title":"Architecture","text":"<p>Votre code Unity         \u2193 AR Foundation (API unifi\u00e9e)     \u2193         \u2193 ARCore      ARKit (Android)   (iOS)</p>"},{"location":"intro_arcore/#avantages","title":"Avantages","text":"<ul> <li>\u2705 Un seul code pour Android et iOS</li> <li>\u2705 API simplifi\u00e9e par rapport \u00e0 ARCore natif</li> <li>\u2705 Composants Unity int\u00e9gr\u00e9s</li> <li>\u2705 Simulation dans l'\u00e9diteur Unity</li> </ul>"},{"location":"intro_arcore/#composants-principaux-dar-foundation","title":"Composants principaux d'AR Foundation","text":"Composant R\u00f4le AR Session G\u00e8re la session AR (tracking, mise \u00e0 jour) AR Session Origin Point de r\u00e9f\u00e9rence de la sc\u00e8ne AR AR Camera Cam\u00e9ra sp\u00e9ciale pour afficher le monde r\u00e9el AR Plane Manager G\u00e8re la d\u00e9tection de plans AR Raycast Manager Permet de faire des raycasts AR AR Anchor Manager G\u00e8re les ancres"},{"location":"intro_arcore/#workflow-typique-dune-app-ar","title":"Workflow typique d'une app AR","text":"<p>Voici le workflow que vous utiliserez dans vos projets :</p>"},{"location":"intro_arcore/#1-setup-initial-une-fois","title":"1. Setup initial (une fois)","text":"<ul> <li>Installer AR Foundation</li> <li>Configurer les param\u00e8tres du projet</li> <li>Ajouter les composants AR \u00e0 la sc\u00e8ne</li> </ul>"},{"location":"intro_arcore/#2-initialisation-au-demarrage","title":"2. Initialisation (au d\u00e9marrage)","text":"<ul> <li>ARCore d\u00e9marre</li> <li>Demander \u00e0 l'utilisateur de scanner l'environnement</li> <li>Attendre la d\u00e9tection de plans</li> </ul>"},{"location":"intro_arcore/#3-interaction-utilisateur","title":"3. Interaction utilisateur","text":"<pre><code>Utilisateur tape l'\u00e9cran\n    \u00e2\u2020\"\nRaycast AR vers la position du tap\n    \u00e2\u2020\"\nTouche un plan d\u00e9tect\u00e9?\n    \u00e2\u2020\"\nOUI : Cr\u00e9er une ancre \u2192 Placer l'objet\nNON : Ignorer ou afficher feedback\n</code></pre>"},{"location":"intro_arcore/#4-mise-a-jour-continue","title":"4. Mise \u00e0 jour continue","text":"<ul> <li>ARCore met \u00e0 jour le tracking</li> <li>Les plans s'agrandissent/fusionnent</li> <li>Les ancres restent stables</li> </ul>"},{"location":"intro_arcore/#differences-cles-ar-vs-developpement-3d-classique","title":"Diff\u00e9rences cl\u00e9s : AR vs d\u00e9veloppement 3D classique","text":"Aspect 3D Classique AR avec ARCore Environnement Enti\u00e8rement contr\u00f4l\u00e9 Monde r\u00e9el + virtuel Cam\u00e9ra Contr\u00f4le libre Position = position r\u00e9elle de l'appareil Surfaces Cr\u00e9\u00e9es manuellement D\u00e9tect\u00e9es automatiquement Lumi\u00e8re Configur\u00e9e manuellement Estim\u00e9e depuis l'environnement \u00c9chelle Arbitraire M\u00e8tres r\u00e9els Input Clavier/souris Tactile uniquement"},{"location":"intro_arcore/#prerequis-techniques","title":"Pr\u00e9requis techniques","text":""},{"location":"intro_arcore/#materiel-necessaire","title":"Mat\u00e9riel n\u00e9cessaire","text":"<ul> <li>Appareil Android compatible ARCore (liste officielle)</li> <li>OU Utilisation de la simulation AR (recommand\u00e9 pour le d\u00e9veloppement)</li> </ul>"},{"location":"intro_arcore/#versions-logicielles","title":"Versions logicielles","text":"<ul> <li>Unity 2022.3 LTS ou plus r\u00e9cent</li> <li>AR Foundation 5.0+</li> <li>Google ARCore XR Plugin 5.0+</li> </ul>"},{"location":"intro_arcore/#limites-et-defis-darcore","title":"Limites et d\u00e9fis d'ARCore","text":"<p>Il est important de conna\u00eetre les limites :</p>"},{"location":"intro_arcore/#limitations-techniques","title":"Limitations techniques","text":"<ul> <li>\u274c Surfaces transparentes : Difficiles \u00e0 d\u00e9tecter (verre, eau)</li> <li>\u274c Surfaces uniformes : Peu de points caract\u00e9ristiques (mur blanc)</li> <li>\u274c Objets en mouvement : Peuvent perturber le tracking</li> <li>\u274c \u00c9clairage faible : D\u00e9tection moins pr\u00e9cise</li> <li>\u274c Surfaces brillantes : Peuvent causer des reflets</li> </ul>"},{"location":"intro_arcore/#bonnes-pratiques","title":"Bonnes pratiques","text":"<ul> <li>\u2705 Demander \u00e0 l'utilisateur de bien \u00e9clairer la pi\u00e8ce</li> <li>\u2705 Encourager le mouvement lent pour un meilleur tracking</li> <li>\u2705 Fournir du feedback visuel pendant la d\u00e9tection</li> <li>\u2705 Tester dans diff\u00e9rents environnements</li> </ul>"},{"location":"intro_arcore/#prochaines-etapes","title":"Prochaines \u00e9tapes","text":"<p>Maintenant que vous comprenez les concepts fondamentaux d'ARCore, nous allons :</p> <ol> <li>Installer et configurer AR Foundation dans Unity</li> <li>Utiliser la simulation AR pour d\u00e9velopper sans appareil physique</li> <li>Cr\u00e9er une app simple qui d\u00e9tecte des plans et place des objets</li> </ol>"},{"location":"intro_arcore/#ressources-complementaires","title":"Ressources compl\u00e9mentaires","text":"<ul> <li>Documentation officielle ARCore</li> <li>AR Foundation Package</li> <li>Liste des appareils compatibles</li> <li>Best practices ARCore</li> </ul>"},{"location":"intro_arcore/#questions-de-comprehension","title":"Questions de compr\u00e9hension","text":"<ol> <li>Quels sont les trois piliers fondamentaux d'ARCore?</li> <li>Quelle est la diff\u00e9rence entre un raycasting classique et un raycasting AR?</li> <li>Pourquoi utilise-t-on des ancres plut\u00f4t que de simplement positionner des objets?</li> <li>Dans quelles situations le tracking peut-il \u00eatre \"limit\u00e9\"?</li> <li>Quel est l'avantage d'utiliser AR Foundation plut\u00f4t qu'ARCore directement?</li> </ol> <p>Prochaine \u00e9tape : Configuration d'AR Foundation et utilisation de la simulation AR dans Unity.</p>"},{"location":"intro_environnements_immersifs/","title":"Introduction aux environnements immersifs","text":""},{"location":"intro_environnements_immersifs/#quest-ce-quun-environnement-immersif","title":"Qu'est-ce qu'un environnement immersif?","text":"<p>Un environnement immersif est un espace num\u00e9rique con\u00e7u pour donner \u00e0 l'utilisateur l'impression d'\u00eatre physiquement pr\u00e9sent dans un monde virtuel ou augment\u00e9. L'objectif principal est de cr\u00e9er une exp\u00e9rience o\u00f9 la fronti\u00e8re entre le monde r\u00e9el et le monde num\u00e9rique devient floue.</p>"},{"location":"intro_environnements_immersifs/#caracteristiques-principales","title":"Caract\u00e9ristiques principales","text":"<ul> <li>Immersion sensorielle : Sollicite un ou plusieurs sens (vue, ou\u00efe, toucher)</li> <li>Interaction en temps r\u00e9el : L'utilisateur peut agir et modifier l'environnement</li> <li>Perception de pr\u00e9sence : Sentiment d'\u00eatre \"\u00e0 l'int\u00e9rieur\" de l'exp\u00e9rience</li> <li>Contexte spatial : Les \u00e9l\u00e9ments ont une position et une \u00e9chelle dans l'espace 3D</li> </ul>"},{"location":"intro_environnements_immersifs/#les-deux-grandes-familles-ar-et-vr","title":"Les deux grandes familles : AR et VR","text":""},{"location":"intro_environnements_immersifs/#realite-virtuelle-vr-virtual-reality","title":"R\u00e9alit\u00e9 Virtuelle (VR - Virtual Reality)","text":"<p>La r\u00e9alit\u00e9 virtuelle remplace compl\u00e8tement votre environnement r\u00e9el par un environnement 100% num\u00e9rique.</p> <p>Caract\u00e9ristiques :</p> <ul> <li>Immersion totale dans un monde virtuel</li> <li>Isolation du monde r\u00e9el</li> <li>Contr\u00f4le complet de l'environnement visuel</li> <li>N\u00e9cessite g\u00e9n\u00e9ralement un casque opaque (Meta Quest, HTC Vive, PlayStation VR)</li> </ul> <p>Exemples d'utilisation :</p> <ul> <li>Jeux vid\u00e9o immersifs (Beat Saber, Half-Life: Alyx)</li> <li>Simulations d'entra\u00eenement (pilotage, chirurgie)</li> <li>Visites virtuelles (immobilier, tourisme)</li> <li>Salles de r\u00e9union virtuelles</li> </ul> <p>Avantages :</p> <ul> <li>Immersion maximale</li> <li>Environnement enti\u00e8rement contr\u00f4l\u00e9</li> <li>Pas de contraintes li\u00e9es \u00e0 l'espace physique</li> </ul> <p>D\u00e9fis :</p> <ul> <li>Mal des transports (motion sickness)</li> <li>Isolation sociale</li> <li>\u00c9quipement co\u00fbteux</li> <li>N\u00e9cessite un espace d\u00e9di\u00e9</li> </ul>"},{"location":"intro_environnements_immersifs/#realite-augmentee-ar-augmented-reality","title":"R\u00e9alit\u00e9 Augment\u00e9e (AR - Augmented Reality)","text":"<p>La r\u00e9alit\u00e9 augment\u00e9e superpose des \u00e9l\u00e9ments num\u00e9riques sur votre environnement r\u00e9el.</p> <p>Caract\u00e9ristiques :</p> <ul> <li>Le monde r\u00e9el reste visible</li> <li>Ajout d'informations ou d'objets virtuels contextuels</li> <li>Interaction entre objets r\u00e9els et virtuels</li> <li>Accessible via smartphone, tablette ou lunettes AR (HoloLens, Magic Leap)</li> </ul> <p>Exemples d'utilisation :</p> <ul> <li>Pok\u00e9mon GO (jeu g\u00e9olocalis\u00e9)</li> <li>IKEA Place (visualisation de meubles chez soi)</li> <li>Filtres Instagram/Snapchat</li> <li>Navigation GPS avec directions superpos\u00e9es</li> <li>Maintenance industrielle (instructions superpos\u00e9es sur \u00e9quipement)</li> </ul> <p>Avantages :</p> <ul> <li>Accessible (la plupart ont d\u00e9j\u00e0 un smartphone)</li> <li>Ancrage dans le monde r\u00e9el</li> <li>Utilisation en mobilit\u00e9</li> <li>Applications pratiques imm\u00e9diates</li> </ul> <p>D\u00e9fis :</p> <ul> <li>Pr\u00e9cision du tracking</li> <li>\u00c9clairage et conditions environnementales variables</li> <li>Performance sur appareils mobiles</li> <li>Champ de vision limit\u00e9 (sur t\u00e9l\u00e9phone)</li> </ul>"},{"location":"intro_environnements_immersifs/#comparaison-ar-vs-vr","title":"Comparaison AR vs VR","text":"Crit\u00e8re R\u00e9alit\u00e9 Augment\u00e9e (AR) R\u00e9alit\u00e9 Virtuelle (VR) Environnement Monde r\u00e9el + \u00e9l\u00e9ments virtuels Monde 100% virtuel Isolation Aucune Totale Mat\u00e9riel Smartphone, tablette, lunettes AR Casque VR d\u00e9di\u00e9 Mobilit\u00e9 Haute Limit\u00e9e Co\u00fbt d'entr\u00e9e Faible (appareil existant) \u00c9lev\u00e9 (\u00e9quipement sp\u00e9cialis\u00e9) Complexit\u00e9 technique Mod\u00e9r\u00e9e (tracking environnement r\u00e9el) \u00c9lev\u00e9e (rendu 3D complexe) Cas d'usage typiques Commerce, \u00e9ducation, navigation Gaming, simulation, formation"},{"location":"intro_environnements_immersifs/#la-realite-mixte-mr-mixed-reality","title":"La R\u00e9alit\u00e9 Mixte (MR - Mixed Reality)","text":"<p>Il existe aussi un troisi\u00e8me terme : la r\u00e9alit\u00e9 mixte, qui repr\u00e9sente un spectre entre AR et VR.</p> <p>En r\u00e9alit\u00e9 mixte :</p> <ul> <li>Les objets virtuels peuvent interagir avec les objets r\u00e9els</li> <li>Compr\u00e9hension avanc\u00e9e de l'environnement (g\u00e9om\u00e9trie, surfaces, \u00e9clairage)</li> <li>Exemples : Microsoft HoloLens 2, Apple Vision Pro</li> </ul> <p>Note : La fronti\u00e8re entre AR avanc\u00e9e et MR est floue. Pour ce cours, nous nous concentrerons sur l'AR mobile avec ARCore.</p>"},{"location":"intro_environnements_immersifs/#pourquoi-apprendre-la-realite-augmentee","title":"Pourquoi apprendre la r\u00e9alit\u00e9 augment\u00e9e?","text":""},{"location":"intro_environnements_immersifs/#accessibilite","title":"Accessibilit\u00e9","text":"<p>Des milliards de personnes ont d\u00e9j\u00e0 un appareil compatible AR dans leur poche.</p>"},{"location":"intro_environnements_immersifs/#marche-en-croissance","title":"March\u00e9 en croissance","text":"<ul> <li>Commerce \u00e9lectronique (essai virtuel de produits)</li> <li>\u00c9ducation (mod\u00e8les 3D interactifs)</li> <li>Industrie (maintenance assist\u00e9e)</li> <li>Sant\u00e9 (visualisation m\u00e9dicale)</li> </ul>"},{"location":"intro_environnements_immersifs/#competences-transferables","title":"Comp\u00e9tences transf\u00e9rables","text":"<p>Les concepts appris en AR (tracking 3D, anchors, raycasting) sont applicables en VR et en d\u00e9veloppement 3D g\u00e9n\u00e9ral.</p>"},{"location":"intro_environnements_immersifs/#creativite","title":"Cr\u00e9ativit\u00e9","text":"<p>L'AR permet de cr\u00e9er des exp\u00e9riences uniques qui m\u00e9langent imagination et r\u00e9alit\u00e9.</p>"},{"location":"intro_environnements_immersifs/#technologies-que-nous-utiliserons","title":"Technologies que nous utiliserons","text":""},{"location":"intro_environnements_immersifs/#unity","title":"Unity","text":"<p>Moteur de jeu multiplateforme utilis\u00e9 pour cr\u00e9er des exp\u00e9riences 3D interactives.</p>"},{"location":"intro_environnements_immersifs/#arcore-google","title":"ARCore (Google)","text":"<p>Librairie de r\u00e9alit\u00e9 augment\u00e9e pour Android d\u00e9velopp\u00e9e par Google. Elle fournit :</p> <ul> <li>D\u00e9tection de plans (sols, murs, tables)</li> <li>Tracking de position (suivi du mouvement de l'appareil)</li> <li>Estimation de l'\u00e9clairage (pour un rendu r\u00e9aliste)</li> <li>Ancres (points fixes dans l'espace r\u00e9el)</li> </ul> <p>Note : L'\u00e9quivalent Apple est ARKit. Les concepts sont tr\u00e8s similaires.</p>"},{"location":"intro_environnements_immersifs/#ar-foundation","title":"AR Foundation","text":"<p>Couche d'abstraction Unity qui permet de d\u00e9velopper pour ARCore et ARKit simultan\u00e9ment.</p>"},{"location":"intro_environnements_immersifs/#objectifs-des-4-prochaines-semaines","title":"Objectifs des 4 prochaines semaines","text":"<ol> <li>Semaine 1 : Ma\u00eetriser le raycasting 3D et les bases de l'interaction spatiale</li> <li>Semaine 2 : Comprendre ARCore et utiliser la simulation AR dans Unity</li> <li>Semaine 3 : Approfondir les concepts et planifier un projet int\u00e9gr\u00e9</li> <li>Semaine 4 : D\u00e9velopper et pr\u00e9senter une application AR fonctionnelle (Tic Tac Toe)</li> </ol>"},{"location":"intro_environnements_immersifs/#ressources-complementaires","title":"Ressources compl\u00e9mentaires","text":"<ul> <li>Documentation officielle ARCore</li> <li>AR Foundation Unity</li> <li>Exemples d'applications AR inspirantes</li> </ul>"},{"location":"intro_environnements_immersifs/#questions-de-reflexion","title":"Questions de r\u00e9flexion","text":"<ol> <li>Quelles diff\u00e9rences principales distinguent AR et VR en termes d'exp\u00e9rience utilisateur?</li> <li>Pourquoi l'AR est-elle plus accessible que la VR actuellement?</li> <li>Pouvez-vous penser \u00e0 une application AR qui r\u00e9soudrait un probl\u00e8me quotidien?</li> <li>Dans quels domaines professionnels la r\u00e9alit\u00e9 augment\u00e9e pourrait-elle avoir le plus d'impact selon vous?</li> </ol> <p>Prochaine \u00e9tape : Nous allons explorer le concept fondamental du raycasting 3D dans Unity, pierre angulaire de toute interaction en environnement immersif.</p>"},{"location":"raycasting_3d_theorie/","title":"Raycasting 3D dans Unity","text":""},{"location":"raycasting_3d_theorie/#quest-ce-quun-raycast","title":"Qu'est-ce qu'un raycast?","text":"<p>Un raycast (lancer de rayon) est une technique qui consiste \u00e0 projeter un rayon invisible dans une direction donn\u00e9e pour d\u00e9tecter ce qu'il touche.</p>"},{"location":"raycasting_3d_theorie/#analogie-du-monde-reel","title":"Analogie du monde r\u00e9el","text":"<p>Imaginez que vous pointez un laser :</p> <ul> <li>Le laser part de votre position</li> <li>Il voyage en ligne droite dans la direction o\u00f9 vous pointez</li> <li>Il s'arr\u00eate d\u00e8s qu'il touche quelque chose</li> <li>Vous pouvez alors savoir quoi a \u00e9t\u00e9 touch\u00e9 et o\u00f9 exactement (point sur la cible)</li> </ul> <p>C'est exactement ce que fait un raycast.</p>"},{"location":"raycasting_3d_theorie/#pourquoi-le-raycast-est-il-fondamental","title":"Pourquoi le raycast est-il fondamental?","text":"<p>Le raycasting est la base de presque toutes les interactions en 3D :</p> <ul> <li>Cliquer sur un objet : Lancer un rayon depuis la cam\u00e9ra vers la position du clic</li> <li>D\u00e9tection de sol : V\u00e9rifier si un personnage touche le sol</li> <li>Ligne de vue : Savoir si un ennemi peut \"voir\" le joueur</li> <li>Placement d'objets en AR : Trouver o\u00f9 placer un objet virtuel sur une surface r\u00e9elle</li> </ul> <p>En r\u00e9alit\u00e9 augment\u00e9e, nous utilisons constamment le raycasting pour savoir o\u00f9 l'utilisateur touche l'\u00e9cran et quelle surface correspond \u00e0 l'interaction.</p>"},{"location":"raycasting_3d_theorie/#anatomie-dun-raycast","title":"Anatomie d'un raycast","text":"<p>Un raycast a besoin de trois infromations principales :</p>"},{"location":"raycasting_3d_theorie/#1-point-de-depart-origin","title":"1. Point de d\u00e9part (Origin)","text":"<p>D'o\u00f9 part le rayon? </p> <ul> <li>Position de la cam\u00e9ra</li> <li>Position d'un objet</li> <li>Position du doigt sur l'\u00e9cran (converti en point 3D)</li> </ul>"},{"location":"raycasting_3d_theorie/#2-direction","title":"2. Direction","text":"<p>Dans quelle direction va le rayon?</p> <ul> <li>Direction de la cam\u00e9ra (<code>Camera.main.transform.forward</code>)</li> <li>Direction vers le bas (<code>Vector3.down</code>)</li> <li>Direction calcul\u00e9e entre deux points</li> </ul>"},{"location":"raycasting_3d_theorie/#3-distance-maximale-optionnelle","title":"3. Distance maximale (optionnelle)","text":"<p>Jusqu'o\u00f9 le rayon peut-il voyager avant d'abandonner?</p> <ul> <li>Utile pour limiter la port\u00e9e d'une interaction</li> <li>Am\u00e9liore les performances (moins de calculs)</li> </ul>"},{"location":"raycasting_3d_theorie/#raycasting-dans-unity-la-syntaxe-de-base","title":"Raycasting dans Unity : La syntaxe de base","text":"<pre><code>// Cr\u00e9er un rayon\nRay ray = new Ray(origin, direction);\n\n// Variable pour stocker les informations de collision\nRaycastHit hit;\n\n// Lancer le rayon et v\u00e9rifier s'il touche quelque chose\nif (Physics.Raycast(ray, out hit))\n{\n    // Le rayon a touch\u00e9 quelque chose!\n    Debug.Log(\"Objet touch\u00e9 : \" + hit.collider.gameObject.name);\n    Debug.Log(\"Point d'impact : \" + hit.point);\n}\n</code></pre>"},{"location":"raycasting_3d_theorie/#decomposition","title":"D\u00e9composition","text":"<p><code>Ray ray = new Ray(origin, direction);</code></p> <ul> <li>Cr\u00e9e un rayon avec un point de d\u00e9part et une direction</li> </ul> <p><code>RaycastHit hit;</code></p> <ul> <li>Variable qui contiendra les informations sur ce qui a \u00e9t\u00e9 touch\u00e9</li> <li>C'est comme une \"fiche de rapport\" de la collision</li> </ul> <p><code>Physics.Raycast(ray, out hit)</code></p> <ul> <li>Lance le rayon dans la sc\u00e8ne</li> <li>Retourne <code>true</code> si quelque chose est touch\u00e9</li> <li>Remplit automatiquement <code>hit</code> avec les d\u00e9tails</li> </ul>"},{"location":"raycasting_3d_theorie/#informations-disponibles-dans-raycasthit","title":"Informations disponibles dans RaycastHit","text":"<p>Quand un raycast touche quelque chose, l'objet <code>RaycastHit</code> nous donne plusieurs informations utiles :</p> Propri\u00e9t\u00e9 Type Description <code>hit.point</code> Vector3 Position exacte du point d'impact <code>hit.collider</code> Collider Le composant Collider touch\u00e9 <code>hit.collider.gameObject</code> GameObject L'objet complet qui a \u00e9t\u00e9 touch\u00e9 <code>hit.distance</code> float Distance entre l'origine et le point d'impact <code>hit.normal</code> Vector3 Vecteur perpendiculaire \u00e0 la surface touch\u00e9e <code>hit.transform</code> Transform Le Transform de l'objet touch\u00e9"},{"location":"raycasting_3d_theorie/#exemple-pratique-detecter-un-clic-sur-un-objet","title":"Exemple pratique : D\u00e9tecter un clic sur un objet","text":"<pre><code>using UnityEngine;\n\npublic class RaycastClick : MonoBehaviour\n{\n    void Update()\n    {\n        // V\u00e9rifier si le bouton gauche de la souris est cliqu\u00e9\n        if (Input.GetMouseButtonDown(0))\n        {\n            // Cr\u00e9er un rayon depuis la cam\u00e9ra vers la position de la souris\n            Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);\n            RaycastHit hit;\n\n            // Lancer le rayon\n            if (Physics.Raycast(ray, out hit))\n            {\n                Debug.Log(\"Vous avez cliqu\u00e9 sur : \" + hit.collider.gameObject.name);\n\n                // Changer la couleur de l'objet touch\u00e9\n                Renderer renderer = hit.collider.GetComponent&lt;Renderer&gt;();\n                if (renderer != null)\n                {\n                    renderer.material.color = Color.red;\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"raycasting_3d_theorie/#points-importants","title":"Points importants","text":"<p><code>Camera.main.ScreenPointToRay(Input.mousePosition)</code></p> <ul> <li>Convertit la position 2D de la souris \u00e0 l'\u00e9cran en rayon 3D</li> <li>C'est la m\u00e9thode la plus courante pour les clics</li> </ul> <p><code>Input.GetMouseButtonDown(0)</code></p> <ul> <li>D\u00e9tecte le moment exact o\u00f9 le bouton est enfonc\u00e9</li> <li><code>0</code> = bouton gauche, <code>1</code> = bouton droit, <code>2</code> = bouton du milieu</li> </ul>"},{"location":"raycasting_3d_theorie/#placer-un-objet-au-point-dimpact","title":"Placer un objet au point d'impact","text":"<pre><code>using UnityEngine;\n\npublic class PlacerObjet : MonoBehaviour\n{\n    public GameObject objetAPlacer; // Assignez un prefab dans l'inspecteur\n\n    void Update()\n    {\n        if (Input.GetMouseButtonDown(0))\n        {\n            Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);\n            RaycastHit hit;\n\n            if (Physics.Raycast(ray, out hit))\n            {\n                // Cr\u00e9er l'objet au point d'impact\n                Instantiate(objetAPlacer, hit.point, Quaternion.identity);\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"raycasting_3d_theorie/#les-quaternions-orientation-en-3d","title":"Les quaternions : Orientation en 3D","text":""},{"location":"raycasting_3d_theorie/#quest-ce-quun-quaternion","title":"Qu'est-ce qu'un quaternion?","text":"<p>Un quaternion est une fa\u00e7on math\u00e9matique de repr\u00e9senter une rotation dans l'espace 3D.</p>"},{"location":"raycasting_3d_theorie/#pourquoi-pas-simplement-utiliser-des-angles","title":"Pourquoi pas simplement utiliser des angles?","text":"<p>En 3D, nous avons besoin de trois rotations (X, Y, Z) - on appelle \u00e7a des angles d'Euler. Le probl\u00e8me avec les angles d'Euler :</p> <ol> <li>Gimbal Lock : Dans certaines positions, deux axes se superposent et vous \"perdez\" une dimension de rotation</li> <li>Interpolation : Animer une rotation peut donner des r\u00e9sultats bizarres</li> <li>Ambigu\u00eft\u00e9 : Plusieurs combinaisons d'angles peuvent repr\u00e9senter la m\u00eame rotation</li> </ol> <p>Les quaternions r\u00e9solvent tous ces probl\u00e8mes!</p>"},{"location":"raycasting_3d_theorie/#vulgarisation-ne-pas-y-penser-en-nombres","title":"Vulgarisation : Ne pas y penser en nombres","text":"<p>La bonne nouvelle : Vous n'avez presque jamais besoin de cr\u00e9er un quaternion manuellement!</p> <p>Unity fournit des quaternions \"pr\u00eats \u00e0 l'emploi\" :</p> <pre><code>// Pas de rotation\nQuaternion.identity\n\n// Rotation qui regarde vers une direction\nQuaternion.LookRotation(direction)\n\n// Rotation \u00e0 partir d'angles Euler (si vraiment n\u00e9cessaire)\nQuaternion.Euler(0, 90, 0) // Rotation de 90\u00b0 sur l'axe Y\n\n// Rotation entre deux points\nQuaternion.FromToRotation(pointA, pointB)\n</code></pre>"},{"location":"raycasting_3d_theorie/#quaternionidentity-le-plus-utilise","title":"Quaternion.identity - Le plus utilis\u00e9","text":"<p><code>Quaternion.identity</code> signifie \"aucune rotation\" - c'est l'orientation par d\u00e9faut (0\u00b0, 0\u00b0, 0\u00b0).</p> <p>Quand l'utiliser :</p> <ul> <li>Placer un objet sans rotation sp\u00e9cifique</li> <li>R\u00e9initialiser une rotation</li> <li>Position \"neutre\"</li> </ul> <pre><code>// Cr\u00e9er un cube sans rotation\nInstantiate(cube, position, Quaternion.identity);\n</code></pre>"},{"location":"raycasting_3d_theorie/#quaternionlookrotation-orienter-vers-une-direction","title":"Quaternion.LookRotation - Orienter vers une direction","text":"<p>Souvent, nous voulons qu'un objet \"regarde\" dans une direction particuli\u00e8re.</p> <pre><code>// Orienter un objet vers le point d'impact\nVector3 directionVersImpact = hit.point - transform.position;\nQuaternion rotation = Quaternion.LookRotation(directionVersImpact);\nInstantiate(objet, transform.position, rotation);\n</code></pre>"},{"location":"raycasting_3d_theorie/#aligner-un-objet-sur-une-surface-utiliser-la-normale","title":"Aligner un objet sur une surface (utiliser la normale)","text":"<p>La normale (<code>hit.normal</code>) est un vecteur perpendiculaire \u00e0 la surface touch\u00e9e. C'est crucial pour placer des objets de mani\u00e8re r\u00e9aliste.</p> <pre><code>if (Physics.Raycast(ray, out hit))\n{\n    // Rotation qui aligne l'objet perpendiculairement \u00e0 la surface\n    Quaternion rotation = Quaternion.FromToRotation(Vector3.up, hit.normal);\n\n    Instantiate(objetAPlacer, hit.point, rotation);\n}\n</code></pre>"},{"location":"raycasting_3d_theorie/#visualisation-de-la-normale","title":"Visualisation de la normale","text":"<pre><code>        ^ hit.normal (perpendiculaire)\n        |\n        |\n    --------  Surface\n</code></pre> <p>Pourquoi Vector3.up?</p> <ul> <li>Par d\u00e9faut, les objets Unity sont orient\u00e9s vers le haut (axe Y positif)</li> <li><code>FromToRotation</code> calcule la rotation n\u00e9cessaire pour aller de \"up\" vers la normale</li> <li>R\u00e9sultat : l'objet s'aligne parfaitement avec la surface</li> </ul>"},{"location":"raycasting_3d_theorie/#filtrer-les-collisions-avec-les-layers","title":"Filtrer les collisions avec les Layers","text":"<p>Parfois, nous voulons ignorer certains objets. Unity utilise des Layers (couches) pour cat\u00e9goriser les objets.</p>"},{"location":"raycasting_3d_theorie/#creer-et-assigner-des-layers","title":"Cr\u00e9er et assigner des layers","text":"<ol> <li>S\u00e9lectionnez un GameObject</li> <li>En haut de l'Inspector, cliquez sur \"Layer\" \u2192 \"Add Layer...\"</li> <li>Nommez votre layer (ex: \"Ignorable\")</li> <li>Assignez ce layer aux objets que vous voulez ignorer</li> </ol>"},{"location":"raycasting_3d_theorie/#utiliser-un-layermask-dans-le-raycast","title":"Utiliser un LayerMask dans le raycast","text":"<pre><code>// Cr\u00e9er un masque qui ignore la couche \"Ignorable\"\npublic LayerMask layerMask;\n\nvoid Update()\n{\n    if (Input.GetMouseButtonDown(0))\n    {\n        Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);\n        RaycastHit hit;\n\n        // Raycast avec masque de layer\n        if (Physics.Raycast(ray, out hit, Mathf.Infinity, layerMask))\n        {\n            Debug.Log(\"Touch\u00e9 : \" + hit.collider.gameObject.name);\n        }\n    }\n}\n</code></pre>"},{"location":"raycasting_3d_theorie/#configuration-du-layermask-dans-linspector","title":"Configuration du LayerMask dans l'Inspector","text":"<ol> <li>Dans l'Inspector de votre script, vous verrez <code>Layer Mask</code></li> <li>D\u00e9cochez les layers que vous voulez ignorer</li> <li>Les objets sur ces layers seront invisibles pour ce raycast</li> </ol> <p>Astuce : Vous pouvez aussi inverser la logique en code :</p> <pre><code>// Ignorer seulement la couche \"Ignorable\"\nint layerMask = ~LayerMask.GetMask(\"Ignorable\");\nPhysics.Raycast(ray, out hit, Mathf.Infinity, layerMask);\n</code></pre> <p>Le <code>~</code> inverse le masque (ignorer au lieu d'inclure).</p>"},{"location":"raycasting_3d_theorie/#visualiser-les-rayons-en-mode-scene","title":"Visualiser les rayons en mode Scene","text":"<p>Pour d\u00e9boguer, il est utile de voir les rayons :</p> <pre><code>// Dessiner une ligne visible dans la Scene (pas en Game)\nDebug.DrawRay(origin, direction * distance, Color.red, 2f);\n\n// OU\nDebug.DrawLine(startPoint, endPoint, Color.green, 2f);\n</code></pre> <p>Param\u00e8tres :</p> <ul> <li>Couleur : Color.red, Color.green, etc.</li> <li>Dur\u00e9e : Temps en secondes (2f = 2 secondes)</li> </ul> <p>Ces lignes sont visibles uniquement dans la vue Scene de l'\u00e9diteur Unity.</p>"},{"location":"raycasting_3d_theorie/#bonnes-pratiques","title":"Bonnes pratiques","text":""},{"location":"raycasting_3d_theorie/#1-toujours-verifier-si-la-camera-existe","title":"1. Toujours v\u00e9rifier si la cam\u00e9ra existe","text":"<pre><code>if (Camera.main == null)\n{\n    Debug.LogError(\"Aucune cam\u00e9ra principale trouv\u00e9e!\");\n    return;\n}\n</code></pre>"},{"location":"raycasting_3d_theorie/#2-utiliser-une-distance-maximale-pour-la-performance","title":"2. Utiliser une distance maximale pour la performance","text":"<pre><code>float maxDistance = 100f;\nif (Physics.Raycast(ray, out hit, maxDistance))\n{\n    // ...\n}\n</code></pre>"},{"location":"raycasting_3d_theorie/#3-verifier-les-composants-avant-de-les-utiliser","title":"3. V\u00e9rifier les composants avant de les utiliser","text":"<pre><code>Renderer renderer = hit.collider.GetComponent&lt;Renderer&gt;();\nif (renderer != null)\n{\n    renderer.material.color = Color.blue;\n}\nelse\n{\n    Debug.LogWarning(\"Pas de Renderer sur cet objet!\");\n}\n</code></pre>"},{"location":"raycasting_3d_theorie/#4-les-objets-doivent-avoir-un-collider","title":"4. Les objets doivent avoir un Collider","text":"<p>Pour qu'un raycast d\u00e9tecte un objet, cet objet doit avoir un composant Collider (BoxCollider, SphereCollider, MeshCollider, etc.).</p>"},{"location":"raycasting_3d_theorie/#differences-entre-raycast-et-raycastall","title":"Diff\u00e9rences entre Raycast et RaycastAll","text":""},{"location":"raycasting_3d_theorie/#physicsraycast","title":"Physics.Raycast()","text":"<ul> <li>S'arr\u00eate au premier objet touch\u00e9</li> <li>Plus performant</li> <li>Parfait pour la plupart des cas</li> </ul>"},{"location":"raycasting_3d_theorie/#physicsraycastall","title":"Physics.RaycastAll()","text":"<ul> <li>Retourne tous les objets touch\u00e9s le long du rayon</li> <li>Retourne un tableau de RaycastHit</li> <li>Utile pour voir \u00e0 travers des objets, compter les collisions</li> </ul> <pre><code>RaycastHit[] hits = Physics.RaycastAll(ray);\nforeach (RaycastHit hit in hits)\n{\n    Debug.Log(\"Travers\u00e9 : \" + hit.collider.gameObject.name);\n}\n</code></pre>"},{"location":"raycasting_3d_theorie/#resume-des-concepts-cles","title":"R\u00e9sum\u00e9 des concepts cl\u00e9s","text":"Concept Utilit\u00e9 Ray Ligne invisible qui part d'un point dans une direction RaycastHit Informations sur ce qui a \u00e9t\u00e9 touch\u00e9 hit.point Position exacte de l'impact (crucial pour placer des objets) hit.normal Orientation de la surface (pour aligner des objets) Quaternion.identity Pas de rotation (0\u00b0, 0\u00b0, 0\u00b0) Quaternion.FromToRotation Calculer rotation entre deux directions LayerMask Filtrer quels objets peuvent \u00eatre touch\u00e9s"},{"location":"raycasting_3d_theorie/#questions-de-comprehension","title":"Questions de compr\u00e9hension","text":"<ol> <li>Quelle est la diff\u00e9rence entre <code>Ray</code> et <code>RaycastHit</code>?</li> <li>Pourquoi avons-nous besoin de <code>hit.normal</code> pour placer des objets sur des surfaces inclin\u00e9es?</li> <li>Dans quel sc\u00e9nario utiliseriez-vous <code>Physics.RaycastAll()</code> au lieu de <code>Physics.Raycast()</code>?</li> <li>Que signifie <code>Quaternion.identity</code> et quand l'utiliser?</li> <li>Comment faire pour qu'un raycast ignore certains objets?</li> </ol>"},{"location":"reference_input_actions/","title":"R\u00e9f\u00e9rence rapide - Unity Input System (Input Actions)","text":""},{"location":"reference_input_actions/#pourquoi-utiliser-input-actions","title":"Pourquoi utiliser Input Actions?","text":"<p>\u2705 Multi-plateforme : M\u00eame code pour clavier/souris, tactile, manette \u2705 Rebinding : L'utilisateur peut changer les contr\u00f4les \u2705 S\u00e9paration : Configuration s\u00e9par\u00e9e du code \u2705 \u00c9v\u00e9nements : Syst\u00e8me bas\u00e9 sur des callbacks </p> <p>Important pour AR : En r\u00e9alit\u00e9 augment\u00e9e, vous utiliserez principalement les actions Point (position du doigt) et Tap (toucher l'\u00e9cran). Le syst\u00e8me fonctionne automatiquement sur mobile.</p>"},{"location":"reference_input_actions/#1-creer-un-input-actions-asset","title":"1. Cr\u00e9er un Input Actions Asset","text":""},{"location":"reference_input_actions/#11-creer-un-asset","title":"1.1 Cr\u00e9er un asset","text":"<ol> <li>Dans le Project (fen\u00eatre Assets), clic droit</li> <li>Create \u2192 Input Actions</li> <li>Nommez-le <code>PlayerInputActions</code> (ou autre nom descriptif)</li> <li>Double-cliquez dessus pour l'ouvrir</li> </ol> <p>Pour le cours : La plupart du temps vous modifierez le Input Action Asset par d\u00e9fault du projet.</p>"},{"location":"reference_input_actions/#12-comprendre-la-structure","title":"1.2 Comprendre la structure","text":"<p>L'\u00e9diteur d'Input Actions a trois colonnes :</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Action Maps    \u2502    Actions       \u2502     Bindings        \u2502\n\u2502  (Cat\u00e9gories)   \u2502  (Ce qu'on fait) \u2502  (Comment le faire) \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Player         \u2502  Move            \u2502  WASD               \u2502\n\u2502  UI             \u2502  Jump            \u2502  Space              \u2502\n\u2502  Menu           \u2502  Fire            \u2502  Mouse Left Click   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <ul> <li>Action Map : Ensemble d'actions li\u00e9es (ex: \"Player\", \"UI\", \"Menu\")</li> <li>Action : Une action sp\u00e9cifique (ex: \"Jump\", \"Fire\", \"Point\")</li> <li>Binding : Quelle touche/bouton d\u00e9clenche l'action</li> </ul>"},{"location":"reference_input_actions/#2-creer-de-nouvelles-actions","title":"2. Cr\u00e9er de nouvelles actions","text":""},{"location":"reference_input_actions/#21-ajouter-une-action-map-si-necessaire","title":"2.1 Ajouter une Action Map (si n\u00e9cessaire)","text":"<ol> <li>Cliquez sur le + \u00e0 c\u00f4t\u00e9 de \"Action Maps\"</li> <li>Nommez-la (ex: \"Gameplay\", \"AR\", \"Menu\")</li> </ol> <p>Par d\u00e9faut, Unity cr\u00e9e souvent une map \"Player\" - vous pouvez l'utiliser directement.</p>"},{"location":"reference_input_actions/#22-ajouter-une-action","title":"2.2 Ajouter une Action","text":"<ol> <li>S\u00e9lectionnez votre Action Map (ex: \"Player\")</li> <li>Dans la colonne \"Actions\", cliquez sur +</li> <li>Nommez votre action (ex: \"PlaceObject\", \"DeleteObject\")</li> </ol>"},{"location":"reference_input_actions/#23-configurer-le-type-daction","title":"2.3 Configurer le type d'action","text":"<p>Chaque action a un Action Type :</p> Type Usage Exemple Button Action binaire (press\u00e9/rel\u00e2ch\u00e9) Tirer, Sauter, Placer Value Valeur continue Position souris, Joystick Pass Through Valeur continue sans traitement Position tactile brute <p>Pour la plupart des actions AR, utilisez Button.</p> <p>Configuration :</p> <ol> <li>S\u00e9lectionnez votre action</li> <li>Dans l'Inspector (panneau de droite), choisissez Action Type</li> </ol>"},{"location":"reference_input_actions/#24-ajouter-un-binding-touchebouton","title":"2.4 Ajouter un Binding (Touche/Bouton)","text":"<ol> <li>S\u00e9lectionnez votre action</li> <li>Dans la colonne \"Bindings\", cliquez sur +</li> <li>Choisissez le type :</li> <li>Add Binding : Touche/bouton simple</li> <li>Add Positive/Negative Binding : Pour axes (ex: gauche/droite)</li> <li> <p>Add 2D Vector Composite : Pour mouvement (WASD, Joystick)</p> </li> <li> <p>Cliquez sur le binding cr\u00e9\u00e9</p> </li> <li>Cliquez sur Path et s\u00e9lectionnez la touche/bouton</li> </ol> <p>Exemples courants :</p> <pre><code>Action: PlacerObjet\n\u251c\u2500 Binding: Mouse \u2192 Left Button\n\u2514\u2500 Binding: Touchscreen \u2192 Primary Touch \u2192 Tap\n\nAction: SupprimerObjet\n\u251c\u2500 Binding: Mouse \u2192 Right Button\n\u2514\u2500 Binding: Touchscreen \u2192 Primary Touch \u2192 Long Press\n\nAction: PositionPointeur\n\u2514\u2500 Binding: Mouse \u2192 Position\n</code></pre>"},{"location":"reference_input_actions/#3-actions-pre-configurees-utiles-pour-ar","title":"3. Actions pr\u00e9-configur\u00e9es utiles pour AR","text":""},{"location":"reference_input_actions/#action-point-position-du-pointeur","title":"Action Point (Position du pointeur)","text":"<p>Usage : Obtenir la position de la souris ou du doigt sur l'\u00e9cran.</p> <p>Configuration :</p> <ol> <li>Nom : <code>Point</code> ou <code>PointerPosition</code></li> <li>Action Type : Value</li> <li>Control Type : Vector 2</li> <li> <p>Bindings :</p> </li> <li> <p>Mouse \u2192 Position</p> </li> <li>Touchscreen \u2192 Primary Touch \u2192 Position</li> </ol>"},{"location":"reference_input_actions/#action-tap-toucherclic","title":"Action Tap (Toucher/Clic)","text":"<p>Usage : D\u00e9tecter un tap/clic.</p> <p>Configuration :</p> <ol> <li>Nom : <code>Tap</code> ou <code>PlaceObject</code></li> <li>Action Type : Button</li> <li> <p>Bindings :</p> </li> <li> <p>Mouse \u2192 Left Button</p> </li> <li>Touchscreen \u2192 Primary Touch \u2192 Tap</li> </ol>"},{"location":"reference_input_actions/#action-hold-maintien-prolonge","title":"Action Hold (Maintien prolong\u00e9)","text":"<p>Usage : Clic long pour supprimer, s\u00e9lectionner, etc.</p> <p>Configuration :</p> <ol> <li>Nom : <code>Hold</code> ou <code>LongPress</code></li> <li>Action Type : Button</li> <li> <p>Bindings :</p> </li> <li> <p>Mouse \u2192 Right Button</p> </li> <li> <p>Touchscreen \u2192 Primary Touch \u2192 Press</p> </li> <li> <p>Dans le binding tactile, ajoutez une Interaction \u2192 Hold</p> </li> <li> <p>Configurez Hold Time (ex: 0.5 secondes)</p> </li> </ol>"},{"location":"reference_input_actions/#4-generer-la-classe-c","title":"4. G\u00e9n\u00e9rer la classe C","text":"<p>Une fois vos actions configur\u00e9es, vous devez g\u00e9n\u00e9rer une classe C# pour les utiliser dans vos scripts.</p>"},{"location":"reference_input_actions/#41-activer-la-generation","title":"4.1 Activer la g\u00e9n\u00e9ration","text":"<ol> <li>S\u00e9lectionnez votre Input Actions asset dans le Project</li> <li>Dans l'Inspector, cochez Generate C# Class</li> <li>Cliquez sur Apply</li> </ol>"},{"location":"reference_input_actions/#42-configuration-de-generation","title":"4.2 Configuration de g\u00e9n\u00e9ration","text":"<p>Champs importants :</p> <ul> <li>C# Class Name : Nom de la classe g\u00e9n\u00e9r\u00e9e (ex: <code>PlayerInputActions</code>)</li> <li>C# Class Namespace : Optionnel (laissez vide pour simplicit\u00e9)</li> <li>C# Class File : Chemin o\u00f9 le fichier .cs sera cr\u00e9\u00e9</li> </ul> <p>Cliquez sur Apply pour g\u00e9n\u00e9rer le fichier .cs</p> <p>Rappel : Chaque fois que vous modifiez vos actions, cliquez \u00e0 nouveau sur Apply pour r\u00e9g\u00e9n\u00e9rer la classe.</p>"},{"location":"reference_input_actions/#5-utiliser-la-classe-c-dans-vos-scripts","title":"5. Utiliser la classe C# dans vos scripts","text":""},{"location":"reference_input_actions/#51-initialiser-les-input-actions","title":"5.1 Initialiser les Input Actions","text":"<pre><code>using UnityEngine;\n\npublic class InputManager : MonoBehaviour\n{\n    private PlayerInputActions inputActions;\n\n    void Awake()\n    {\n        // Cr\u00e9er une instance des Input Actions\n        inputActions = new PlayerInputActions();\n    }\n\n    void OnEnable()\n    {\n        // IMPORTANT : Activer les actions\n        inputActions.Enable();\n    }\n\n    void OnDisable()\n    {\n        // IMPORTANT : D\u00e9sactiver pour \u00e9viter les fuites m\u00e9moire\n        inputActions.Disable();\n    }\n}\n</code></pre> <p>Points critiques :</p> <ul> <li>\u2705 Cr\u00e9er dans <code>Awake()</code></li> <li>\u2705 <code>Enable()</code> dans <code>OnEnable()</code></li> <li>\u2705 <code>Disable()</code> dans <code>OnDisable()</code></li> </ul>"},{"location":"reference_input_actions/#52-structure-de-la-classe-generee","title":"5.2 Structure de la classe g\u00e9n\u00e9r\u00e9e","text":"<p>Si vous avez une Action Map \"Player\" avec une action \"Fire\", la structure sera :</p> <pre><code>inputActions.Player.Fire\n</code></pre> <p>Format g\u00e9n\u00e9ral :</p> <pre><code>inputActions.[ActionMap].[Action]\n</code></pre>"},{"location":"reference_input_actions/#6-relier-une-action-a-un-evenement-callbacks","title":"6. Relier une action \u00e0 un \u00e9v\u00e9nement (Callbacks)","text":"<p>Il existe trois types d'\u00e9v\u00e9nements pour chaque action :</p>"},{"location":"reference_input_actions/#les-trois-evenements-disponibles","title":"Les trois \u00e9v\u00e9nements disponibles","text":"\u00c9v\u00e9nement D\u00e9clenchement Usage typique started D\u00e8s que l'action commence Pr\u00e9parer une action, feedback visuel performed Action compl\u00e9t\u00e9e Ex\u00e9cuter l'action principale canceled Action annul\u00e9e/rel\u00e2ch\u00e9e R\u00e9initialiser, arr\u00eater une action"},{"location":"reference_input_actions/#61-sabonner-a-un-evenement","title":"6.1 S'abonner \u00e0 un \u00e9v\u00e9nement","text":"<pre><code>void OnEnable()\n{\n    inputActions.Enable();\n\n    // S'abonner \u00e0 l'\u00e9v\u00e9nement \"performed\"\n    inputActions.Player.Fire.performed += OnFirePerformed;\n    inputActions.Player.Fire.started += OnFireStarted;\n    inputActions.Player.Fire.canceled += OnFireCanceled;\n}\n\nvoid OnDisable()\n{\n    // IMPORTANT : Se d\u00e9sabonner pour \u00e9viter les erreurs\n    inputActions.Player.Fire.performed -= OnFirePerformed;\n    inputActions.Player.Fire.started -= OnFireStarted;\n    inputActions.Player.Fire.canceled -= OnFireCanceled;\n\n    inputActions.Disable();\n}\n\n// M\u00e9thodes appel\u00e9es par les \u00e9v\u00e9nements\nvoid OnFirePerformed(UnityEngine.InputSystem.InputAction.CallbackContext context)\n{\n    Debug.Log(\"Fire performed!\");\n}\n\nvoid OnFireStarted(UnityEngine.InputSystem.InputAction.CallbackContext context)\n{\n    Debug.Log(\"Fire started!\");\n}\n\nvoid OnFireCanceled(UnityEngine.InputSystem.InputAction.CallbackContext context)\n{\n    Debug.Log(\"Fire canceled!\");\n}\n</code></pre>"},{"location":"reference_input_actions/#62-difference-entre-started-performed-canceled","title":"6.2 Diff\u00e9rence entre started, performed, canceled","text":"<p>Exemple avec un bouton simple :</p> <pre><code>Utilisateur appuie sur le bouton :\n\u251c\u2500 started \u2500\u2500\u2500\u25ba D\u00e9clench\u00e9 imm\u00e9diatement\n\u2502\nUtilisateur maintient :\n\u251c\u2500 performed \u2500\u25ba D\u00e9clench\u00e9 (action compl\u00e8te)\n\u2502\nUtilisateur rel\u00e2che :\n\u2514\u2500 canceled \u2500\u2500\u25ba D\u00e9clench\u00e9 au rel\u00e2chement\n</code></pre> <p>Exemple avec Hold Interaction (maintien 0.5s) :</p> <pre><code>Utilisateur appuie :\n\u251c\u2500 started \u2500\u2500\u2500\u25ba Imm\u00e9diat\n\u2502\nMaintien &lt; 0.5s, puis rel\u00e2che :\n\u251c\u2500 canceled \u2500\u2500\u25ba Action annul\u00e9e (pas assez long)\n\u2502\nMaintien &gt; 0.5s :\n\u2514\u2500 performed \u2500\u25ba Action compl\u00e9t\u00e9e (assez long)\n</code></pre>"},{"location":"reference_input_actions/#63-quel-evenement-utiliser","title":"6.3 Quel \u00e9v\u00e9nement utiliser?","text":"<p>Pour la plupart des cas en AR, utilisez <code>performed</code> :</p> <pre><code>inputActions.Player.Tap.performed += OnTap;\n\nvoid OnTap(InputAction.CallbackContext context)\n{\n    // Placer un objet, tirer, etc.\n}\n</code></pre> <p>Utilisez <code>started</code> pour feedback instantan\u00e9 :</p> <pre><code>inputActions.Player.Tap.started += OnTapStarted;\n\nvoid OnTapStarted(InputAction.CallbackContext context)\n{\n    // Montrer un effet visuel de \"tap en cours\"\n    ShowTapEffect();\n}\n</code></pre> <p>Utilisez <code>canceled</code> pour r\u00e9initialiser :</p> <pre><code>inputActions.Player.Hold.canceled += OnHoldCanceled;\n\nvoid OnHoldCanceled(InputAction.CallbackContext context)\n{\n    // Annuler l'action de maintien\n    HideHoldIndicator();\n}\n</code></pre>"},{"location":"reference_input_actions/#7-lire-des-valeurs-depuis-le-contexte","title":"7. Lire des valeurs depuis le contexte","text":"<p>Le param\u00e8tre <code>CallbackContext context</code> contient les informations sur l'action d\u00e9clench\u00e9e.</p>"},{"location":"reference_input_actions/#71-lire-la-position-de-la-sourisdoigt-vector2","title":"7.1 Lire la position de la souris/doigt (Vector2)","text":"<p>Id\u00e9alement si l'action Point est configur\u00e9e, on peut toujours acc\u00e9der \u00e0 la position avec :</p> <pre><code>Vector2 positionEcran = controles.Player.Pointeur.ReadValue&lt;Vector2&gt;();\n</code></pre> <p>Sinon on prend beaucoup de ressources (1 \u00e9v\u00e9nement d\u00e9clench\u00e9 \u00e0 chaque petit mouvement):</p> <pre><code>using UnityEngine.InputSystem;\n\nvoid OnEnable()\n{\n    inputActions.Enable();\n    inputActions.Player.PointerPosition.performed += OnPointerMove;\n}\n\nvoid OnPointerMove(InputAction.CallbackContext context)\n{\n    // Lire la position (Vector2)\n    Vector2 pointerPosition = context.ReadValue&lt;Vector2&gt;();\n\n    Debug.Log($\"Position : {pointerPosition.x}, {pointerPosition.y}\");\n}\n</code></pre>"},{"location":"reference_input_actions/#72-lire-un-bouton-bool","title":"7.2 Lire un bouton (bool)","text":"<pre><code>void OnFirePerformed(InputAction.CallbackContext context)\n{\n    // Pour les boutons, vous pouvez v\u00e9rifier l'\u00e9tat\n    bool isPressed = context.ReadValueAsButton();\n\n    if (isPressed)\n    {\n        Debug.Log(\"Bouton press\u00e9!\");\n    }\n}\n</code></pre>"},{"location":"reference_input_actions/#73-lire-une-valeur-float","title":"7.3 Lire une valeur float","text":"<pre><code>// Exemple : Trigger de manette (valeur de 0 \u00e0 1)\nvoid OnTriggerPerformed(InputAction.CallbackContext context)\n{\n    float triggerValue = context.ReadValue&lt;float&gt;();\n    Debug.Log($\"Trigger \u00e0 {triggerValue * 100}%\");\n}\n</code></pre>"},{"location":"reference_input_actions/#8-retourner-differentes-valeurs-selon-linput-5-touches-5-valeurs","title":"8. Retourner diff\u00e9rentes valeurs selon l'input (5 touches \u2192 5 valeurs)","text":""},{"location":"reference_input_actions/#methode-1-actions-multiples-recommande","title":"M\u00e9thode 1 : Actions multiples (recommand\u00e9)","text":"<p>Cr\u00e9ez une action par touche, chacune retournant une valeur diff\u00e9rente.</p> <p>Dans Input Actions :</p> <pre><code>SelectColor1 \u2192 Binding: Keyboard/1\nSelectColor2 \u2192 Binding: Keyboard/2\nSelectColor3 \u2192 Binding: Keyboard/3\nSelectColor4 \u2192 Binding: Keyboard/4\nSelectColor5 \u2192 Binding: Keyboard/5\n</code></pre> <p>Dans le code :</p> <pre><code>void OnEnable()\n{\n    inputActions.Enable();\n    inputActions.Player.SelectColor1.performed += ctx =&gt; ChangeColor(0);\n    inputActions.Player.SelectColor2.performed += ctx =&gt; ChangeColor(1);\n    inputActions.Player.SelectColor3.performed += ctx =&gt; ChangeColor(2);\n    inputActions.Player.SelectColor4.performed += ctx =&gt; ChangeColor(3);\n    inputActions.Player.SelectColor5.performed += ctx =&gt; ChangeColor(4);\n}\n\nvoid ChangeColor(int colorIndex)\n{\n    Color[] colors = { Color.red, Color.blue, Color.green, Color.yellow, Color.magenta };\n    currentColor = colors[colorIndex];\n    Debug.Log($\"Couleur chang\u00e9e : {currentColor}\");\n}\n</code></pre>"},{"location":"reference_input_actions/#methode-2-verifier-quelle-touche-a-ete-pressee","title":"M\u00e9thode 2 : V\u00e9rifier quelle touche a \u00e9t\u00e9 press\u00e9e","text":"<p>Si vous voulez une seule action qui d\u00e9tecte plusieurs touches :</p> <p>Dans Input Actions :</p> <pre><code>SelectColor \u2192 Action Type: Button\n  \u251c\u2500 Binding: Keyboard/1\n  \u251c\u2500 Binding: Keyboard/2\n  \u251c\u2500 Binding: Keyboard/3\n  \u251c\u2500 Binding: Keyboard/4\n  \u2514\u2500 Binding: Keyboard/5\n</code></pre> <p>Dans le code :</p> <pre><code>using UnityEngine.InputSystem;\nusing UnityEngine.InputSystem.Controls;\n\nvoid OnEnable()\n{\n    inputActions.Enable();\n    inputActions.Player.SelectColor.performed += OnColorSelect;\n}\n\nvoid OnColorSelect(InputAction.CallbackContext context)\n{\n    // Obtenir le contr\u00f4le qui a d\u00e9clench\u00e9 l'action\n    if (context.control is KeyControl key)\n    {\n        switch (key.keyCode)\n        {\n            case Key.Digit1:\n                ChangeColor(0);\n                break;\n            case Key.Digit2:\n                ChangeColor(1);\n                break;\n            case Key.Digit3:\n                ChangeColor(2);\n                break;\n            case Key.Digit4:\n                ChangeColor(3);\n                break;\n            case Key.Digit5:\n                ChangeColor(4);\n                break;\n        }\n    }\n}\n\nvoid ChangeColor(int colorIndex)\n{\n    Color[] colors = { Color.red, Color.blue, Color.green, Color.yellow, Color.magenta };\n    currentColor = colors[colorIndex];\n}\n</code></pre>"},{"location":"reference_input_actions/#10-configuration-input-actions-recommandee-pour-ar","title":"10. Configuration Input Actions recommand\u00e9e pour AR","text":"<p>Voici une configuration type pour votre projet AR :</p>"},{"location":"reference_input_actions/#action-map-ar","title":"Action Map: \"AR\"","text":"Action Type Bindings Usage Point Value (Vector2) Mouse/Position, Touch/Position Position du pointeur Tap Button Mouse/Left, Touch/Tap Placer objet Hold Button + Hold Mouse/Right, Touch/Press + Hold(0.5s) Supprimer objet Pinch Value (float) Touch/Pinch Zoom (optionnel) Rotate Value (float) Touch/Twist Rotation (optionnel)"},{"location":"reference_input_actions/#depannage-et-erreurs-courantes","title":"D\u00e9pannage et erreurs courantes","text":""},{"location":"reference_input_actions/#the-type-or-namespace-name-inputaction-could-not-be-found","title":"\u274c \"The type or namespace name 'InputAction' could not be found\"","text":"<p>Cause : Package Input System non install\u00e9</p> <p>Solution : 1. Window \u2192 Package Manager 2. Cherchez \"Input System\" 3. Cliquez Install</p>"},{"location":"reference_input_actions/#ambiguous-reference-between-unityengineinput-and-unityengineinputsystem","title":"\u274c \"Ambiguous reference between UnityEngine.Input and UnityEngine.InputSystem\"","text":"<p>Cause : Ancien et nouveau syst\u00e8me en conflit</p> <p>Solution :</p> <pre><code>// Sp\u00e9cifier explicitement\nusing UnityEngine.InputSystem;\n\n// OU renommer\nusing NewInput = UnityEngine.InputSystem;\n</code></pre>"},{"location":"reference_input_actions/#les-actions-ne-se-declenchent-jamais","title":"\u274c Les actions ne se d\u00e9clenchent jamais","text":"<p>Causes possibles : 1. \u274c Oubli\u00e9 <code>inputActions.Enable()</code> 2. \u274c Pas r\u00e9g\u00e9n\u00e9r\u00e9 la classe C# apr\u00e8s modification 3. \u274c Pas d\u00e9sabonn\u00e9/r\u00e9abonn\u00e9 apr\u00e8s modification</p> <p>V\u00e9rifications :</p> <pre><code>void OnEnable()\n{\n    inputActions.Enable(); // \u2190 Ne pas oublier!\n    inputActions.Player.Fire.performed += OnFire;\n}\n</code></pre>"},{"location":"reference_input_actions/#nullreferenceexception-au-demarrage","title":"\u274c \"NullReferenceException\" au d\u00e9marrage","text":"<p>Cause : <code>inputActions</code> non initialis\u00e9</p> <p>Solution :</p> <pre><code>void Awake()\n{\n    inputActions = new PlayerInputActions(); // \u2190 Obligatoire!\n}\n</code></pre>"},{"location":"reference_input_actions/#resume-checklist-rapide","title":"R\u00e9sum\u00e9 - Checklist rapide","text":"<p>Configuration :</p> <ul> <li>[ ] Cr\u00e9er Input Actions Asset</li> <li>[ ] Ajouter Action Map et Actions</li> <li>[ ] Configurer Action Type et Control Type</li> <li>[ ] Ajouter Bindings (touches/boutons)</li> <li>[ ] Cocher \"Generate C# Class\" et Apply</li> </ul> <p>Utilisation :</p> <ul> <li>[ ] Cr\u00e9er instance dans <code>Awake()</code></li> <li>[ ] <code>Enable()</code> dans <code>OnEnable()</code></li> <li>[ ] S'abonner aux \u00e9v\u00e9nements (<code>performed</code>, <code>started</code>, <code>canceled</code>)</li> <li>[ ] Lire les valeurs avec <code>context.ReadValue&lt;T&gt;()</code></li> <li>[ ] Se d\u00e9sabonner dans <code>OnDisable()</code></li> <li>[ ] <code>Disable()</code> dans <code>OnDisable()</code></li> </ul>"},{"location":"reference_input_actions/#ressources-complementaires","title":"Ressources compl\u00e9mentaires","text":"<ul> <li>Documentation Input System</li> <li>Input System Guide</li> <li>Actions Reference</li> </ul>"},{"location":"reference_input_actions/#questions-de-comprehension","title":"Questions de compr\u00e9hension","text":"<ol> <li>Quelle est la diff\u00e9rence entre <code>started</code>, <code>performed</code> et <code>canceled</code>?</li> <li>Pourquoi faut-il appeler <code>Enable()</code> et <code>Disable()</code>?</li> <li>Comment obtenir la position de la souris avec Input Actions?</li> <li>Pourquoi utiliser Input Actions plut\u00f4t que l'ancien <code>Input.GetMouseButtonDown()</code>?</li> <li>Comment associer 5 touches diff\u00e9rentes \u00e0 5 valeurs diff\u00e9rentes?</li> </ol>"}]}